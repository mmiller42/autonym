{
  "type": "File",
  "start": 0,
  "end": 13251,
  "loc": {
    "start": {
      "line": 1,
      "column": 0
    },
    "end": {
      "line": 253,
      "column": 0
    }
  },
  "program": {
    "type": "Program",
    "start": 0,
    "end": 13251,
    "loc": {
      "start": {
        "line": 1,
        "column": 0
      },
      "end": {
        "line": 253,
        "column": 0
      }
    },
    "sourceType": "module",
    "body": [],
    "directives": [],
    "leadingComments": null,
    "innerComments": [
      {
        "type": "CommentBlock",
        "value": " eslint-disable import/unambiguous, max-len ",
        "start": 0,
        "end": 48,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 48
          }
        }
      },
      {
        "type": "CommentBlock",
        "value": "*\n * A plain object that is shared for the given request. It is passed to all policies that execute for the given\n * store method, which can read and mutate it freely, and passed into the given store method. The meta object can be\n * used to add non-serializable data that is useful in the store method, data that is tangentially related to the\n * request but does not belong in the body (such as information about the current user session), cached results of\n * policies that may be repeated in an expression, etc.\n * @typedef {object} Meta\n * @example\n * async function getCurrentUserPolicy(req, res, meta) {\n *   if (meta.user) {\n *     // We already have fetched the user (i.e. this policy has probably already been run in this request).\n *     return\n *   }\n *   const authHeader = req.getHeader('Authorization')\n *   if (!authHeader) {\n *     throw new AutonymError(AutonymError.UNAUTHORIZED, 'You must be logged in to perform this action.')\n *   }\n *\n *   const [, token] = authHeader.split('Bearer ')\n *   const data = await verify(token)\n *   // Save data on meta object, which will be accessible on subsequent policies and store methods.\n *   meta.user = await User.findOne(data.userId)\n * }\n *\n * function canCreatePostPolicy(req, res, meta) {\n *   // Access the user object saved in the previous policy. Note: this means this policy is tightly coupled to the\n *   // getCurrentUserPolicy and will throw an error if it is used in isolation, which would by default return a 500\n *   // error. We *could* `await getCurrentUserPolicy(req, res, meta)` here if we wanted to use this policy alone.\n *   if (!meta.user.privileges.includes('createPost')) {\n *     throw new AutonymError(AutonymError.FORBIDDEN, 'You must have the createPost privilege to perform this action.')\n *   }\n * }\n *\n * const Post = new Model({\n *   name: 'post',\n *   policies: {\n *     create: { and: [getCurrentUserPolicy, canCreatePostPolicy] },\n *   },\n *   store: {\n *     // Since the `getCurrentUserPolicy` was called before inserting, the `user` object is available in the store\n *     // methods. If calling the API programmatically, e.g. `Post.create()`, this data will need to be supplied\n *     // manually in the `create` method, since policies are not called when using the model instance directly.\n *     create: (data, meta) => Db.insert({ ...data, authorId: meta.user.id }),\n *   }\n * })\n ",
        "start": 50,
        "end": 2439,
        "loc": {
          "start": {
            "line": 3,
            "column": 0
          },
          "end": {
            "line": 48,
            "column": 3
          }
        }
      },
      {
        "type": "CommentBlock",
        "value": "*\n * An object mapping store method names to policy hooks. The hooks will be run for the given method. If the value is\n * just `true`, it is assumed that all requests will be honored and no policies are necessary for any lifecycle event;\n * if just `false`, it is assumed no requests will be honored.\n * @typedef {object} ModelPolicies\n * @property {object|boolean} [create] Policies to run for the `create` method.\n * @property {Operand} [create.preSchema] An expression to evaluate before the data is validated against the schema.\n * @property {Operand} [create.postSchema] An expression to evaluate after the data is validated against the schema.\n * @property {Operand} [create.preStore] An expression to evaluate before the data is passed to the store method.\n * @property {Operand} [create.postStore] An expression to evaluate after the store method has completed.\n * @property {object|boolean} [find] Policies to run for the `find` method.\n * @property {Operand} [find.preStore] An expression to evaluate before the data is passed to the store method.\n * @property {Operand} [find.postStore] An expression to evaluate after the store method has completed.\n * @property {object|boolean} [findOne] Policies to run for the `findOne` method.\n * @property {Operand} [findOne.preStore] An expression to evaluate before the data is passed to the store method.\n * @property {Operand} [findOne.postStore] An expression to evaluate after the store method has completed.\n * @property {object|boolean} [findOneAndUpdate] Policies to run for the `findOneAndUpdate` method.\n * @property {Operand} [findOneAndUpdate.preSchema] An expression to evaluate before the data is validated against the\n * schema.\n * @property {Operand} [findOneAndUpdate.postSchema] An expression to evaluate after the data is validated against the\n * schema.\n * @property {Operand} [findOneAndUpdate.preStore] An expression to evaluate before the data is passed to the store\n * method.\n * @property {Operand} [findOneAndUpdate.postStore] An expression to evaluate after the store method has completed.\n * @property {object|boolean} [findOneAndDelete] Policies to run for the `findOneAndDelete` method.\n * @property {Operand} [findOneAndDelete.preStore] An expression to evaluate before the data is passed to the store\n * method.\n * @property {Operand} [findOneAndDelete.postStore] An expression to evaluate after the store method has completed.\n * @example\n * const Post = new Model({\n *   name: 'post',\n *   policies: {\n *     create: {\n *       // Users must be logged in and have the proper permission to create a post\n *       preSchema: { and: [getCurrentUserPolicy, canCreatePostPolicy] },\n *       // Once the post is validated, it is safe to read and manipulate the request data\n *       postSchema: trimPostBodyPolicy,\n *     },\n *     find: {\n *       // All requests to get all posts should include a header with the total count\n *       postStore: addTotalCountHeaderToResponsePolicy,\n *     },\n *     findOneAndUpdate: {\n *       // Users must be logged in and own the post that they are trying to update\n *       preSchema: { and: [getCurrentUserPolicy, userIsOwnerOfPostPolicy] },\n *       postSchema: trimPostBodyPolicy,\n *     },\n *     findOneAndDelete: {\n *       preStore: { and: [getCurrentUserPolicy, userIsOwnerOfPostPolicy] },\n *     },\n *   },\n *   store: {},\n * })\n ",
        "start": 2441,
        "end": 5804,
        "loc": {
          "start": {
            "line": 50,
            "column": 0
          },
          "end": {
            "line": 103,
            "column": 3
          }
        }
      },
      {
        "type": "CommentBlock",
        "value": "*\n * An operand is a boolean (to explicitly allow or deny) or a policy function, or an AndExpression, OrExpression, or\n * NotExpression, which can be used to assemble more complex policies out of a series of policy functions.\n * AndExpressions, OrExpressions, and NotExpressions may be nested recursively. For details, see the documentation\n * of [async-boolean-expression-evaluator](https://github.com/mmiller42/async-boolean-expression-evaluator).\n * @typedef {boolean|Policy|AndExpression|OrExpression|NotExpression} Operand\n ",
        "start": 5806,
        "end": 6339,
        "loc": {
          "start": {
            "line": 105,
            "column": 0
          },
          "end": {
            "line": 111,
            "column": 3
          }
        }
      },
      {
        "type": "CommentBlock",
        "value": "*\n * An object with the key `and` set to an array of Operands. The expression will only evaluate to true if none of\n * the operands are false or throw errors. The error of the first policy to throw will be used, and short-circuiting\n * will prevent further policies from executing when one throws.\n * @typedef {object} AndExpression\n * @property {Operand[]} and\n ",
        "start": 6341,
        "end": 6708,
        "loc": {
          "start": {
            "line": 113,
            "column": 0
          },
          "end": {
            "line": 119,
            "column": 3
          }
        }
      },
      {
        "type": "CommentBlock",
        "value": "*\n * An object with the key `or` set to an array of Operands. The expression will only evaluate to true if at least\n * one of the operands is true or does not throw an error. The error of the last policy that throws will be used,\n * and short-circuiting will prevent further policies from executing when one does not throw.\n * @typedef {object} OrExpression\n * @property {Operand[]} or\n ",
        "start": 6710,
        "end": 7101,
        "loc": {
          "start": {
            "line": 121,
            "column": 0
          },
          "end": {
            "line": 127,
            "column": 3
          }
        }
      },
      {
        "type": "CommentBlock",
        "value": "*\n * An object with the key `not` set to an Operand. The expression will only evaluate to true if the result of the\n * operand is false or throws an error (which will be swallowed). If the result is true or does not throw an error,\n * a generic error will be thrown, so implement a custom policy if you require a more specific error message.\n * @typedef {object} NotExpression\n * @property {Operand} not\n ",
        "start": 7103,
        "end": 7512,
        "loc": {
          "start": {
            "line": 129,
            "column": 0
          },
          "end": {
            "line": 135,
            "column": 3
          }
        }
      },
      {
        "type": "CommentBlock",
        "value": "*\n * A function that is evaluated before a store method. It may modify the request data, validate the data and throw an\n * error, or determine that the client may not perform this request and throw an error. Policies may be combined in\n * an expression and applied to various store methods in a model's configuration.\n * @typedef {function(req: AutonymReq, res: AutonymRes, meta: Meta): Promise.<*, Error>|*} Policy\n * @example\n * async function getCurrentUserPolicy(req, res, meta) {\n *   if (meta.user) {\n *     // We already have fetched the user (i.e. this policy has probably already been run in this request).\n *     return\n *   }\n *   const authHeader = req.getHeader('Authorization')\n *   if (!authHeader) {\n *     throw new AutonymError(AutonymError.UNAUTHORIZED, 'You must be logged in to perform this action.')\n *   }\n *\n *   const [, token] = authHeader.split('Bearer ')\n *   const data = await verify(token)\n *   // Save data on meta object, which will be accessible on subsequent policies and store methods.\n *   meta.user = await User.findOne(data.userId)\n * }\n * @example\n * function canCreatePostPolicy(req, res, meta) {\n *   // Access the user object saved in the previous policy. Note: this means this policy is tightly coupled to the\n *   // getCurrentUserPolicy and will throw an error if it is used in isolation, which would by default return a 500\n *   // error. We *could* `await getCurrentUserPolicy(req, res, meta)` here if we wanted to use this policy alone.\n *   if (!meta.user.privileges.includes('createPost')) {\n *     throw new AutonymError(AutonymError.FORBIDDEN, 'You must have the createPost privilege to perform this action.')\n *   }\n * }\n * @example\n * function userIsOwnerOfPostPolicy(req, res, meta) {\n *   if (req.getId() !== req.meta.user.id) {\n *     throw new AutonymError(AutonymError.FORBIDDEN, 'You are not the owner of this post.')\n *   }\n * }\n * @example\n * function trimPostBodyPolicy(req, res, meta) {\n *   // If this policy is in the postSchema hook, it is safe to get and set data.\n *   req.setData({ body: req.getData().body.trim() })\n * }\n * @example\n * Post.count = () => Db.selectCount('posts')\n *\n * async function addTotalCountHeaderToResponsePolicy(req, res, meta) {\n *   // If this policy is in the postStore hook, it is safe to get and modify the response data.\n *\n *   const model = req.getModel()\n *   if (model.count) {\n *     const totalCount = await req.getModel().count()\n *     res.setHeader('X-Total-Count', totalCount)\n *   }\n * }\n ",
        "start": 7514,
        "end": 10020,
        "loc": {
          "start": {
            "line": 137,
            "column": 0
          },
          "end": {
            "line": 190,
            "column": 3
          }
        }
      },
      {
        "type": "CommentBlock",
        "value": "*\n * An object that has methods for CRUD operations for a typical record. It does not matter if this is a plain\n * object or an instance of a Store class, as long as it has these members on it.\n * @typedef {object} Store\n * @property {function(data: SerializedRecord, meta: Meta, unserializedData: Record):\n * Promise.<SerializedRecord, Error>|SerializedRecord} [create] A function called to create a new record.\n * @property {function(query: object, meta: Meta): Promise.<SerializedRecord[], Error>|SerializedRecord[]} [find]\n * A function called to find records.\n * @property {function(id: string, meta: Meta): Promise.<SerializedRecord, Error>|SerializedRecord} [findOne] A\n * function called to find a single record.\n * @property {function(id: string, data: SerializedRecord, completeData: SerializedRecord, meta: Meta, unserializedData: Record, unserializedCompleteData: Record):\n * Promise.<SerializedRecord, Error>|SerializedRecord} [findOneAndUpdate] A function called to update a single record.\n * @property {function(id: string, meta: Meta): Promise.<*, Error>|*} [findOneAndDelete] A function called to delete\n * a single record.\n * @param {function(data: Record): Promise.<SerializedRecord, Error>|SerializedRecord} [serialize] A function\n * called to reformat the request body automatically before passing it into the `create` and `findOneAndUpdate`\n * store methods. It must be able to handle partial data objects.\n * @param {function(data: SerializedRecord): Promise.<Record, Error>|Record} [unserialize] A function called to\n * reformat the store method's return value automatically before passing it into `postStore` policies and\n * subsequently to the response.\n * @example\n * const Post = new Model({\n *   name: 'post',\n *   store: {\n *     create: data => Db.insert('posts', data),\n *     find: () => Db.selectAll('posts'),\n *     findOne: id => Db.selectOne('posts', { id }),\n *     findOneAndUpdate: (id, data) => Db.updateWhere('posts', { id }, data),\n *     findOneAndDelete: id => Db.deleteWhere('posts', { id }),\n *\n *     // Column names are the same as properties on the data, but in snake-case\n *     serialize: data => mapKeys(data, property => snakeCase(property)),\n *     // Properties are the same as column names in the table, but in camel-case\n *     unserialize: data => mapKeys(data, columnName => camelCase(columnName)),\n *   },\n * })\n ",
        "start": 10022,
        "end": 12400,
        "loc": {
          "start": {
            "line": 192,
            "column": 0
          },
          "end": {
            "line": 228,
            "column": 3
          }
        }
      },
      {
        "type": "CommentBlock",
        "value": "*\n * An object that represents a record that may be operated on by a model. A record may be partial (e.g. if it is\n * the properties to update in a findOneAndUpdate request). If it is the result of a store method, it should at\n * least have an `id` property.\n * @typedef {object} Record\n ",
        "start": 12402,
        "end": 12694,
        "loc": {
          "start": {
            "line": 230,
            "column": 0
          },
          "end": {
            "line": 235,
            "column": 3
          }
        }
      },
      {
        "type": "CommentBlock",
        "value": "*\n * A Record that has been transformed by the serialize function as a matter of convenience. It is only used in the\n * store methods and is always unserialized back into a Record before being passed onto other code outside the\n * store methods.\n * @typedef {object} SerializedRecord\n ",
        "start": 12696,
        "end": 12985,
        "loc": {
          "start": {
            "line": 237,
            "column": 0
          },
          "end": {
            "line": 242,
            "column": 3
          }
        }
      },
      {
        "type": "CommentBlock",
        "value": "*\n * A JSON schema object. [Read more about JSON Schema](http://json-schema.org/)\n * @typedef {object} Schema\n ",
        "start": 12987,
        "end": 13102,
        "loc": {
          "start": {
            "line": 244,
            "column": 0
          },
          "end": {
            "line": 247,
            "column": 3
          }
        }
      },
      {
        "type": "CommentBlock",
        "value": "*\n * Options to pass to the JSON schema validator. [See options](https://github.com/epoberezkin/ajv#options)\n * @typedef {object} AjvOptions\n ",
        "start": 13104,
        "end": 13250,
        "loc": {
          "start": {
            "line": 249,
            "column": 0
          },
          "end": {
            "line": 252,
            "column": 3
          }
        }
      }
    ]
  },
  "comments": [
    {
      "type": "CommentBlock",
      "value": " eslint-disable import/unambiguous, max-len ",
      "start": 0,
      "end": 48,
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1,
          "column": 48
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * A plain object that is shared for the given request. It is passed to all policies that execute for the given\n * store method, which can read and mutate it freely, and passed into the given store method. The meta object can be\n * used to add non-serializable data that is useful in the store method, data that is tangentially related to the\n * request but does not belong in the body (such as information about the current user session), cached results of\n * policies that may be repeated in an expression, etc.\n * @typedef {object} Meta\n * @example\n * async function getCurrentUserPolicy(req, res, meta) {\n *   if (meta.user) {\n *     // We already have fetched the user (i.e. this policy has probably already been run in this request).\n *     return\n *   }\n *   const authHeader = req.getHeader('Authorization')\n *   if (!authHeader) {\n *     throw new AutonymError(AutonymError.UNAUTHORIZED, 'You must be logged in to perform this action.')\n *   }\n *\n *   const [, token] = authHeader.split('Bearer ')\n *   const data = await verify(token)\n *   // Save data on meta object, which will be accessible on subsequent policies and store methods.\n *   meta.user = await User.findOne(data.userId)\n * }\n *\n * function canCreatePostPolicy(req, res, meta) {\n *   // Access the user object saved in the previous policy. Note: this means this policy is tightly coupled to the\n *   // getCurrentUserPolicy and will throw an error if it is used in isolation, which would by default return a 500\n *   // error. We *could* `await getCurrentUserPolicy(req, res, meta)` here if we wanted to use this policy alone.\n *   if (!meta.user.privileges.includes('createPost')) {\n *     throw new AutonymError(AutonymError.FORBIDDEN, 'You must have the createPost privilege to perform this action.')\n *   }\n * }\n *\n * const Post = new Model({\n *   name: 'post',\n *   policies: {\n *     create: { and: [getCurrentUserPolicy, canCreatePostPolicy] },\n *   },\n *   store: {\n *     // Since the `getCurrentUserPolicy` was called before inserting, the `user` object is available in the store\n *     // methods. If calling the API programmatically, e.g. `Post.create()`, this data will need to be supplied\n *     // manually in the `create` method, since policies are not called when using the model instance directly.\n *     create: (data, meta) => Db.insert({ ...data, authorId: meta.user.id }),\n *   }\n * })\n ",
      "start": 50,
      "end": 2439,
      "loc": {
        "start": {
          "line": 3,
          "column": 0
        },
        "end": {
          "line": 48,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * An object mapping store method names to policy hooks. The hooks will be run for the given method. If the value is\n * just `true`, it is assumed that all requests will be honored and no policies are necessary for any lifecycle event;\n * if just `false`, it is assumed no requests will be honored.\n * @typedef {object} ModelPolicies\n * @property {object|boolean} [create] Policies to run for the `create` method.\n * @property {Operand} [create.preSchema] An expression to evaluate before the data is validated against the schema.\n * @property {Operand} [create.postSchema] An expression to evaluate after the data is validated against the schema.\n * @property {Operand} [create.preStore] An expression to evaluate before the data is passed to the store method.\n * @property {Operand} [create.postStore] An expression to evaluate after the store method has completed.\n * @property {object|boolean} [find] Policies to run for the `find` method.\n * @property {Operand} [find.preStore] An expression to evaluate before the data is passed to the store method.\n * @property {Operand} [find.postStore] An expression to evaluate after the store method has completed.\n * @property {object|boolean} [findOne] Policies to run for the `findOne` method.\n * @property {Operand} [findOne.preStore] An expression to evaluate before the data is passed to the store method.\n * @property {Operand} [findOne.postStore] An expression to evaluate after the store method has completed.\n * @property {object|boolean} [findOneAndUpdate] Policies to run for the `findOneAndUpdate` method.\n * @property {Operand} [findOneAndUpdate.preSchema] An expression to evaluate before the data is validated against the\n * schema.\n * @property {Operand} [findOneAndUpdate.postSchema] An expression to evaluate after the data is validated against the\n * schema.\n * @property {Operand} [findOneAndUpdate.preStore] An expression to evaluate before the data is passed to the store\n * method.\n * @property {Operand} [findOneAndUpdate.postStore] An expression to evaluate after the store method has completed.\n * @property {object|boolean} [findOneAndDelete] Policies to run for the `findOneAndDelete` method.\n * @property {Operand} [findOneAndDelete.preStore] An expression to evaluate before the data is passed to the store\n * method.\n * @property {Operand} [findOneAndDelete.postStore] An expression to evaluate after the store method has completed.\n * @example\n * const Post = new Model({\n *   name: 'post',\n *   policies: {\n *     create: {\n *       // Users must be logged in and have the proper permission to create a post\n *       preSchema: { and: [getCurrentUserPolicy, canCreatePostPolicy] },\n *       // Once the post is validated, it is safe to read and manipulate the request data\n *       postSchema: trimPostBodyPolicy,\n *     },\n *     find: {\n *       // All requests to get all posts should include a header with the total count\n *       postStore: addTotalCountHeaderToResponsePolicy,\n *     },\n *     findOneAndUpdate: {\n *       // Users must be logged in and own the post that they are trying to update\n *       preSchema: { and: [getCurrentUserPolicy, userIsOwnerOfPostPolicy] },\n *       postSchema: trimPostBodyPolicy,\n *     },\n *     findOneAndDelete: {\n *       preStore: { and: [getCurrentUserPolicy, userIsOwnerOfPostPolicy] },\n *     },\n *   },\n *   store: {},\n * })\n ",
      "start": 2441,
      "end": 5804,
      "loc": {
        "start": {
          "line": 50,
          "column": 0
        },
        "end": {
          "line": 103,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * An operand is a boolean (to explicitly allow or deny) or a policy function, or an AndExpression, OrExpression, or\n * NotExpression, which can be used to assemble more complex policies out of a series of policy functions.\n * AndExpressions, OrExpressions, and NotExpressions may be nested recursively. For details, see the documentation\n * of [async-boolean-expression-evaluator](https://github.com/mmiller42/async-boolean-expression-evaluator).\n * @typedef {boolean|Policy|AndExpression|OrExpression|NotExpression} Operand\n ",
      "start": 5806,
      "end": 6339,
      "loc": {
        "start": {
          "line": 105,
          "column": 0
        },
        "end": {
          "line": 111,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * An object with the key `and` set to an array of Operands. The expression will only evaluate to true if none of\n * the operands are false or throw errors. The error of the first policy to throw will be used, and short-circuiting\n * will prevent further policies from executing when one throws.\n * @typedef {object} AndExpression\n * @property {Operand[]} and\n ",
      "start": 6341,
      "end": 6708,
      "loc": {
        "start": {
          "line": 113,
          "column": 0
        },
        "end": {
          "line": 119,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * An object with the key `or` set to an array of Operands. The expression will only evaluate to true if at least\n * one of the operands is true or does not throw an error. The error of the last policy that throws will be used,\n * and short-circuiting will prevent further policies from executing when one does not throw.\n * @typedef {object} OrExpression\n * @property {Operand[]} or\n ",
      "start": 6710,
      "end": 7101,
      "loc": {
        "start": {
          "line": 121,
          "column": 0
        },
        "end": {
          "line": 127,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * An object with the key `not` set to an Operand. The expression will only evaluate to true if the result of the\n * operand is false or throws an error (which will be swallowed). If the result is true or does not throw an error,\n * a generic error will be thrown, so implement a custom policy if you require a more specific error message.\n * @typedef {object} NotExpression\n * @property {Operand} not\n ",
      "start": 7103,
      "end": 7512,
      "loc": {
        "start": {
          "line": 129,
          "column": 0
        },
        "end": {
          "line": 135,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * A function that is evaluated before a store method. It may modify the request data, validate the data and throw an\n * error, or determine that the client may not perform this request and throw an error. Policies may be combined in\n * an expression and applied to various store methods in a model's configuration.\n * @typedef {function(req: AutonymReq, res: AutonymRes, meta: Meta): Promise.<*, Error>|*} Policy\n * @example\n * async function getCurrentUserPolicy(req, res, meta) {\n *   if (meta.user) {\n *     // We already have fetched the user (i.e. this policy has probably already been run in this request).\n *     return\n *   }\n *   const authHeader = req.getHeader('Authorization')\n *   if (!authHeader) {\n *     throw new AutonymError(AutonymError.UNAUTHORIZED, 'You must be logged in to perform this action.')\n *   }\n *\n *   const [, token] = authHeader.split('Bearer ')\n *   const data = await verify(token)\n *   // Save data on meta object, which will be accessible on subsequent policies and store methods.\n *   meta.user = await User.findOne(data.userId)\n * }\n * @example\n * function canCreatePostPolicy(req, res, meta) {\n *   // Access the user object saved in the previous policy. Note: this means this policy is tightly coupled to the\n *   // getCurrentUserPolicy and will throw an error if it is used in isolation, which would by default return a 500\n *   // error. We *could* `await getCurrentUserPolicy(req, res, meta)` here if we wanted to use this policy alone.\n *   if (!meta.user.privileges.includes('createPost')) {\n *     throw new AutonymError(AutonymError.FORBIDDEN, 'You must have the createPost privilege to perform this action.')\n *   }\n * }\n * @example\n * function userIsOwnerOfPostPolicy(req, res, meta) {\n *   if (req.getId() !== req.meta.user.id) {\n *     throw new AutonymError(AutonymError.FORBIDDEN, 'You are not the owner of this post.')\n *   }\n * }\n * @example\n * function trimPostBodyPolicy(req, res, meta) {\n *   // If this policy is in the postSchema hook, it is safe to get and set data.\n *   req.setData({ body: req.getData().body.trim() })\n * }\n * @example\n * Post.count = () => Db.selectCount('posts')\n *\n * async function addTotalCountHeaderToResponsePolicy(req, res, meta) {\n *   // If this policy is in the postStore hook, it is safe to get and modify the response data.\n *\n *   const model = req.getModel()\n *   if (model.count) {\n *     const totalCount = await req.getModel().count()\n *     res.setHeader('X-Total-Count', totalCount)\n *   }\n * }\n ",
      "start": 7514,
      "end": 10020,
      "loc": {
        "start": {
          "line": 137,
          "column": 0
        },
        "end": {
          "line": 190,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * An object that has methods for CRUD operations for a typical record. It does not matter if this is a plain\n * object or an instance of a Store class, as long as it has these members on it.\n * @typedef {object} Store\n * @property {function(data: SerializedRecord, meta: Meta, unserializedData: Record):\n * Promise.<SerializedRecord, Error>|SerializedRecord} [create] A function called to create a new record.\n * @property {function(query: object, meta: Meta): Promise.<SerializedRecord[], Error>|SerializedRecord[]} [find]\n * A function called to find records.\n * @property {function(id: string, meta: Meta): Promise.<SerializedRecord, Error>|SerializedRecord} [findOne] A\n * function called to find a single record.\n * @property {function(id: string, data: SerializedRecord, completeData: SerializedRecord, meta: Meta, unserializedData: Record, unserializedCompleteData: Record):\n * Promise.<SerializedRecord, Error>|SerializedRecord} [findOneAndUpdate] A function called to update a single record.\n * @property {function(id: string, meta: Meta): Promise.<*, Error>|*} [findOneAndDelete] A function called to delete\n * a single record.\n * @param {function(data: Record): Promise.<SerializedRecord, Error>|SerializedRecord} [serialize] A function\n * called to reformat the request body automatically before passing it into the `create` and `findOneAndUpdate`\n * store methods. It must be able to handle partial data objects.\n * @param {function(data: SerializedRecord): Promise.<Record, Error>|Record} [unserialize] A function called to\n * reformat the store method's return value automatically before passing it into `postStore` policies and\n * subsequently to the response.\n * @example\n * const Post = new Model({\n *   name: 'post',\n *   store: {\n *     create: data => Db.insert('posts', data),\n *     find: () => Db.selectAll('posts'),\n *     findOne: id => Db.selectOne('posts', { id }),\n *     findOneAndUpdate: (id, data) => Db.updateWhere('posts', { id }, data),\n *     findOneAndDelete: id => Db.deleteWhere('posts', { id }),\n *\n *     // Column names are the same as properties on the data, but in snake-case\n *     serialize: data => mapKeys(data, property => snakeCase(property)),\n *     // Properties are the same as column names in the table, but in camel-case\n *     unserialize: data => mapKeys(data, columnName => camelCase(columnName)),\n *   },\n * })\n ",
      "start": 10022,
      "end": 12400,
      "loc": {
        "start": {
          "line": 192,
          "column": 0
        },
        "end": {
          "line": 228,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * An object that represents a record that may be operated on by a model. A record may be partial (e.g. if it is\n * the properties to update in a findOneAndUpdate request). If it is the result of a store method, it should at\n * least have an `id` property.\n * @typedef {object} Record\n ",
      "start": 12402,
      "end": 12694,
      "loc": {
        "start": {
          "line": 230,
          "column": 0
        },
        "end": {
          "line": 235,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * A Record that has been transformed by the serialize function as a matter of convenience. It is only used in the\n * store methods and is always unserialized back into a Record before being passed onto other code outside the\n * store methods.\n * @typedef {object} SerializedRecord\n ",
      "start": 12696,
      "end": 12985,
      "loc": {
        "start": {
          "line": 237,
          "column": 0
        },
        "end": {
          "line": 242,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * A JSON schema object. [Read more about JSON Schema](http://json-schema.org/)\n * @typedef {object} Schema\n ",
      "start": 12987,
      "end": 13102,
      "loc": {
        "start": {
          "line": 244,
          "column": 0
        },
        "end": {
          "line": 247,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * Options to pass to the JSON schema validator. [See options](https://github.com/epoberezkin/ajv#options)\n * @typedef {object} AjvOptions\n ",
      "start": 13104,
      "end": 13250,
      "loc": {
        "start": {
          "line": 249,
          "column": 0
        },
        "end": {
          "line": 252,
          "column": 3
        }
      }
    }
  ],
  "tokens": [
    {
      "type": "CommentBlock",
      "value": " eslint-disable import/unambiguous, max-len ",
      "start": 0,
      "end": 48,
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1,
          "column": 48
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * A plain object that is shared for the given request. It is passed to all policies that execute for the given\n * store method, which can read and mutate it freely, and passed into the given store method. The meta object can be\n * used to add non-serializable data that is useful in the store method, data that is tangentially related to the\n * request but does not belong in the body (such as information about the current user session), cached results of\n * policies that may be repeated in an expression, etc.\n * @typedef {object} Meta\n * @example\n * async function getCurrentUserPolicy(req, res, meta) {\n *   if (meta.user) {\n *     // We already have fetched the user (i.e. this policy has probably already been run in this request).\n *     return\n *   }\n *   const authHeader = req.getHeader('Authorization')\n *   if (!authHeader) {\n *     throw new AutonymError(AutonymError.UNAUTHORIZED, 'You must be logged in to perform this action.')\n *   }\n *\n *   const [, token] = authHeader.split('Bearer ')\n *   const data = await verify(token)\n *   // Save data on meta object, which will be accessible on subsequent policies and store methods.\n *   meta.user = await User.findOne(data.userId)\n * }\n *\n * function canCreatePostPolicy(req, res, meta) {\n *   // Access the user object saved in the previous policy. Note: this means this policy is tightly coupled to the\n *   // getCurrentUserPolicy and will throw an error if it is used in isolation, which would by default return a 500\n *   // error. We *could* `await getCurrentUserPolicy(req, res, meta)` here if we wanted to use this policy alone.\n *   if (!meta.user.privileges.includes('createPost')) {\n *     throw new AutonymError(AutonymError.FORBIDDEN, 'You must have the createPost privilege to perform this action.')\n *   }\n * }\n *\n * const Post = new Model({\n *   name: 'post',\n *   policies: {\n *     create: { and: [getCurrentUserPolicy, canCreatePostPolicy] },\n *   },\n *   store: {\n *     // Since the `getCurrentUserPolicy` was called before inserting, the `user` object is available in the store\n *     // methods. If calling the API programmatically, e.g. `Post.create()`, this data will need to be supplied\n *     // manually in the `create` method, since policies are not called when using the model instance directly.\n *     create: (data, meta) => Db.insert({ ...data, authorId: meta.user.id }),\n *   }\n * })\n ",
      "start": 50,
      "end": 2439,
      "loc": {
        "start": {
          "line": 3,
          "column": 0
        },
        "end": {
          "line": 48,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * An object mapping store method names to policy hooks. The hooks will be run for the given method. If the value is\n * just `true`, it is assumed that all requests will be honored and no policies are necessary for any lifecycle event;\n * if just `false`, it is assumed no requests will be honored.\n * @typedef {object} ModelPolicies\n * @property {object|boolean} [create] Policies to run for the `create` method.\n * @property {Operand} [create.preSchema] An expression to evaluate before the data is validated against the schema.\n * @property {Operand} [create.postSchema] An expression to evaluate after the data is validated against the schema.\n * @property {Operand} [create.preStore] An expression to evaluate before the data is passed to the store method.\n * @property {Operand} [create.postStore] An expression to evaluate after the store method has completed.\n * @property {object|boolean} [find] Policies to run for the `find` method.\n * @property {Operand} [find.preStore] An expression to evaluate before the data is passed to the store method.\n * @property {Operand} [find.postStore] An expression to evaluate after the store method has completed.\n * @property {object|boolean} [findOne] Policies to run for the `findOne` method.\n * @property {Operand} [findOne.preStore] An expression to evaluate before the data is passed to the store method.\n * @property {Operand} [findOne.postStore] An expression to evaluate after the store method has completed.\n * @property {object|boolean} [findOneAndUpdate] Policies to run for the `findOneAndUpdate` method.\n * @property {Operand} [findOneAndUpdate.preSchema] An expression to evaluate before the data is validated against the\n * schema.\n * @property {Operand} [findOneAndUpdate.postSchema] An expression to evaluate after the data is validated against the\n * schema.\n * @property {Operand} [findOneAndUpdate.preStore] An expression to evaluate before the data is passed to the store\n * method.\n * @property {Operand} [findOneAndUpdate.postStore] An expression to evaluate after the store method has completed.\n * @property {object|boolean} [findOneAndDelete] Policies to run for the `findOneAndDelete` method.\n * @property {Operand} [findOneAndDelete.preStore] An expression to evaluate before the data is passed to the store\n * method.\n * @property {Operand} [findOneAndDelete.postStore] An expression to evaluate after the store method has completed.\n * @example\n * const Post = new Model({\n *   name: 'post',\n *   policies: {\n *     create: {\n *       // Users must be logged in and have the proper permission to create a post\n *       preSchema: { and: [getCurrentUserPolicy, canCreatePostPolicy] },\n *       // Once the post is validated, it is safe to read and manipulate the request data\n *       postSchema: trimPostBodyPolicy,\n *     },\n *     find: {\n *       // All requests to get all posts should include a header with the total count\n *       postStore: addTotalCountHeaderToResponsePolicy,\n *     },\n *     findOneAndUpdate: {\n *       // Users must be logged in and own the post that they are trying to update\n *       preSchema: { and: [getCurrentUserPolicy, userIsOwnerOfPostPolicy] },\n *       postSchema: trimPostBodyPolicy,\n *     },\n *     findOneAndDelete: {\n *       preStore: { and: [getCurrentUserPolicy, userIsOwnerOfPostPolicy] },\n *     },\n *   },\n *   store: {},\n * })\n ",
      "start": 2441,
      "end": 5804,
      "loc": {
        "start": {
          "line": 50,
          "column": 0
        },
        "end": {
          "line": 103,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * An operand is a boolean (to explicitly allow or deny) or a policy function, or an AndExpression, OrExpression, or\n * NotExpression, which can be used to assemble more complex policies out of a series of policy functions.\n * AndExpressions, OrExpressions, and NotExpressions may be nested recursively. For details, see the documentation\n * of [async-boolean-expression-evaluator](https://github.com/mmiller42/async-boolean-expression-evaluator).\n * @typedef {boolean|Policy|AndExpression|OrExpression|NotExpression} Operand\n ",
      "start": 5806,
      "end": 6339,
      "loc": {
        "start": {
          "line": 105,
          "column": 0
        },
        "end": {
          "line": 111,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * An object with the key `and` set to an array of Operands. The expression will only evaluate to true if none of\n * the operands are false or throw errors. The error of the first policy to throw will be used, and short-circuiting\n * will prevent further policies from executing when one throws.\n * @typedef {object} AndExpression\n * @property {Operand[]} and\n ",
      "start": 6341,
      "end": 6708,
      "loc": {
        "start": {
          "line": 113,
          "column": 0
        },
        "end": {
          "line": 119,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * An object with the key `or` set to an array of Operands. The expression will only evaluate to true if at least\n * one of the operands is true or does not throw an error. The error of the last policy that throws will be used,\n * and short-circuiting will prevent further policies from executing when one does not throw.\n * @typedef {object} OrExpression\n * @property {Operand[]} or\n ",
      "start": 6710,
      "end": 7101,
      "loc": {
        "start": {
          "line": 121,
          "column": 0
        },
        "end": {
          "line": 127,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * An object with the key `not` set to an Operand. The expression will only evaluate to true if the result of the\n * operand is false or throws an error (which will be swallowed). If the result is true or does not throw an error,\n * a generic error will be thrown, so implement a custom policy if you require a more specific error message.\n * @typedef {object} NotExpression\n * @property {Operand} not\n ",
      "start": 7103,
      "end": 7512,
      "loc": {
        "start": {
          "line": 129,
          "column": 0
        },
        "end": {
          "line": 135,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * A function that is evaluated before a store method. It may modify the request data, validate the data and throw an\n * error, or determine that the client may not perform this request and throw an error. Policies may be combined in\n * an expression and applied to various store methods in a model's configuration.\n * @typedef {function(req: AutonymReq, res: AutonymRes, meta: Meta): Promise.<*, Error>|*} Policy\n * @example\n * async function getCurrentUserPolicy(req, res, meta) {\n *   if (meta.user) {\n *     // We already have fetched the user (i.e. this policy has probably already been run in this request).\n *     return\n *   }\n *   const authHeader = req.getHeader('Authorization')\n *   if (!authHeader) {\n *     throw new AutonymError(AutonymError.UNAUTHORIZED, 'You must be logged in to perform this action.')\n *   }\n *\n *   const [, token] = authHeader.split('Bearer ')\n *   const data = await verify(token)\n *   // Save data on meta object, which will be accessible on subsequent policies and store methods.\n *   meta.user = await User.findOne(data.userId)\n * }\n * @example\n * function canCreatePostPolicy(req, res, meta) {\n *   // Access the user object saved in the previous policy. Note: this means this policy is tightly coupled to the\n *   // getCurrentUserPolicy and will throw an error if it is used in isolation, which would by default return a 500\n *   // error. We *could* `await getCurrentUserPolicy(req, res, meta)` here if we wanted to use this policy alone.\n *   if (!meta.user.privileges.includes('createPost')) {\n *     throw new AutonymError(AutonymError.FORBIDDEN, 'You must have the createPost privilege to perform this action.')\n *   }\n * }\n * @example\n * function userIsOwnerOfPostPolicy(req, res, meta) {\n *   if (req.getId() !== req.meta.user.id) {\n *     throw new AutonymError(AutonymError.FORBIDDEN, 'You are not the owner of this post.')\n *   }\n * }\n * @example\n * function trimPostBodyPolicy(req, res, meta) {\n *   // If this policy is in the postSchema hook, it is safe to get and set data.\n *   req.setData({ body: req.getData().body.trim() })\n * }\n * @example\n * Post.count = () => Db.selectCount('posts')\n *\n * async function addTotalCountHeaderToResponsePolicy(req, res, meta) {\n *   // If this policy is in the postStore hook, it is safe to get and modify the response data.\n *\n *   const model = req.getModel()\n *   if (model.count) {\n *     const totalCount = await req.getModel().count()\n *     res.setHeader('X-Total-Count', totalCount)\n *   }\n * }\n ",
      "start": 7514,
      "end": 10020,
      "loc": {
        "start": {
          "line": 137,
          "column": 0
        },
        "end": {
          "line": 190,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * An object that has methods for CRUD operations for a typical record. It does not matter if this is a plain\n * object or an instance of a Store class, as long as it has these members on it.\n * @typedef {object} Store\n * @property {function(data: SerializedRecord, meta: Meta, unserializedData: Record):\n * Promise.<SerializedRecord, Error>|SerializedRecord} [create] A function called to create a new record.\n * @property {function(query: object, meta: Meta): Promise.<SerializedRecord[], Error>|SerializedRecord[]} [find]\n * A function called to find records.\n * @property {function(id: string, meta: Meta): Promise.<SerializedRecord, Error>|SerializedRecord} [findOne] A\n * function called to find a single record.\n * @property {function(id: string, data: SerializedRecord, completeData: SerializedRecord, meta: Meta, unserializedData: Record, unserializedCompleteData: Record):\n * Promise.<SerializedRecord, Error>|SerializedRecord} [findOneAndUpdate] A function called to update a single record.\n * @property {function(id: string, meta: Meta): Promise.<*, Error>|*} [findOneAndDelete] A function called to delete\n * a single record.\n * @param {function(data: Record): Promise.<SerializedRecord, Error>|SerializedRecord} [serialize] A function\n * called to reformat the request body automatically before passing it into the `create` and `findOneAndUpdate`\n * store methods. It must be able to handle partial data objects.\n * @param {function(data: SerializedRecord): Promise.<Record, Error>|Record} [unserialize] A function called to\n * reformat the store method's return value automatically before passing it into `postStore` policies and\n * subsequently to the response.\n * @example\n * const Post = new Model({\n *   name: 'post',\n *   store: {\n *     create: data => Db.insert('posts', data),\n *     find: () => Db.selectAll('posts'),\n *     findOne: id => Db.selectOne('posts', { id }),\n *     findOneAndUpdate: (id, data) => Db.updateWhere('posts', { id }, data),\n *     findOneAndDelete: id => Db.deleteWhere('posts', { id }),\n *\n *     // Column names are the same as properties on the data, but in snake-case\n *     serialize: data => mapKeys(data, property => snakeCase(property)),\n *     // Properties are the same as column names in the table, but in camel-case\n *     unserialize: data => mapKeys(data, columnName => camelCase(columnName)),\n *   },\n * })\n ",
      "start": 10022,
      "end": 12400,
      "loc": {
        "start": {
          "line": 192,
          "column": 0
        },
        "end": {
          "line": 228,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * An object that represents a record that may be operated on by a model. A record may be partial (e.g. if it is\n * the properties to update in a findOneAndUpdate request). If it is the result of a store method, it should at\n * least have an `id` property.\n * @typedef {object} Record\n ",
      "start": 12402,
      "end": 12694,
      "loc": {
        "start": {
          "line": 230,
          "column": 0
        },
        "end": {
          "line": 235,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * A Record that has been transformed by the serialize function as a matter of convenience. It is only used in the\n * store methods and is always unserialized back into a Record before being passed onto other code outside the\n * store methods.\n * @typedef {object} SerializedRecord\n ",
      "start": 12696,
      "end": 12985,
      "loc": {
        "start": {
          "line": 237,
          "column": 0
        },
        "end": {
          "line": 242,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * A JSON schema object. [Read more about JSON Schema](http://json-schema.org/)\n * @typedef {object} Schema\n ",
      "start": 12987,
      "end": 13102,
      "loc": {
        "start": {
          "line": 244,
          "column": 0
        },
        "end": {
          "line": 247,
          "column": 3
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * Options to pass to the JSON schema validator. [See options](https://github.com/epoberezkin/ajv#options)\n * @typedef {object} AjvOptions\n ",
      "start": 13104,
      "end": 13250,
      "loc": {
        "start": {
          "line": 249,
          "column": 0
        },
        "end": {
          "line": 252,
          "column": 3
        }
      }
    },
    {
      "type": {
        "label": "eof",
        "beforeExpr": false,
        "startsExpr": false,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null,
        "updateContext": null
      },
      "start": 13251,
      "end": 13251,
      "loc": {
        "start": {
          "line": 253,
          "column": 0
        },
        "end": {
          "line": 253,
          "column": 0
        }
      }
    }
  ]
}