[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 49,
    "kind": "external",
    "name": "http~ClientRequest",
    "externalLink": "https://nodejs.org/dist/latest/docs/api/http.html#http_class_http_clientrequest",
    "memberof": "src/.external-nodejs.js",
    "static": true,
    "longname": "src/.external-nodejs.js~http~ClientRequest",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 50,
    "kind": "file",
    "name": "src/AutonymError.js",
    "content": "import HTTP from 'http-status-codes'\n\n/**\n * Wrapper for any error that occurred in a policy or store method.\n */\nexport default class AutonymError {\n  /**\n   * Code indicating the server could not understand the request due to invalid syntax.\n   * @constant\n   * @type {string}\n   */\n  static BAD_REQUEST = 'BAD_REQUEST'\n\n  /**\n   * Code indicating the client does not have access rights to the content.\n   * @constant\n   * @type {string}\n   */\n  static FORBIDDEN = 'FORBIDDEN'\n\n  /**\n   * Code indicating the requested store method is not available for this model.\n   * @constant\n   * @type {string}\n   */\n  static METHOD_NOT_ALLOWED = 'METHOD_NOT_ALLOWED'\n\n  /**\n   * Code indicating the requested resource does not exist.\n   * @constant\n   * @type {string}\n   */\n  static NOT_FOUND = 'NOT_FOUND'\n\n  /**\n   * Code indicating the client must be authenticated to perform this action.\n   * @constant\n   * @type {string}\n   */\n  static UNAUTHORIZED = 'UNAUTHORIZED'\n\n  /**\n   * Code indicating the request was improper, i.e. failed schema validation.\n   * @constant\n   * @type {string}\n   */\n  static UNPROCESSABLE_ENTITY = 'UNPROCESSABLE_ENTITY'\n\n  /**\n   * Default. Code indicating an unhandled error occurred while the server was processing the request.\n   * @constant\n   * @type {string}\n   */\n  static INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR'\n\n  /**\n   * The error codes that indicate client request errors, rather than internal errors.\n   * @constant\n   * @type {string[]}\n   */\n  static CLIENT_ERRORS = [\n    AutonymError.BAD_REQUEST,\n    AutonymError.FORBIDDEN,\n    AutonymError.METHOD_NOT_ALLOWED,\n    AutonymError.NOT_FOUND,\n    AutonymError.UNAUTHORIZED,\n    AutonymError.UNPROCESSABLE_ENTITY,\n  ]\n\n  /**\n   * Wraps the given error and returns an instance of AutonymError, or returns the given error if it already is an\n   * AutonymError. If the error object has the property `code`, it will be used as the AutonymError code. If the\n   * error object implements a `toJSON` method, its result will be stored as additional data.\n   * @param {Error} error An error object.\n   * @returns {AutonymError} The instance of AutonymError.\n   * @example\n   * const err = new Error('Something bad happened')\n   * const autonymError = AutonymError.fromError(err)\n   * console.log(autonymError.getPayload()) // { message: 'An internal server error occurred.' }\n   * @example\n   * const err = new Error('Something bad happened')\n   * err.code = AutonymError.BAD_REQUEST\n   * const autonymError = AutonymError.fromError(err)\n   * // Still internal server error until we call `#toClientError()`\n   * console.log(autonymError.getPayload()) // { message: 'An internal server error occurred.' }\n   */\n  static fromError(error) {\n    if (error.isAutonymError) {\n      return error\n    } else {\n      const autonymError = new AutonymError(\n        error.code || AutonymError.INTERNAL_SERVER_ERROR,\n        error.message || 'An unknown error occurred.',\n        typeof error.toJSON === 'function' ? error.toJSON() : error\n      )\n      autonymError.stack = error.stack\n      return autonymError\n    }\n  }\n\n  /**\n   * @param {string} [code] One of the error code static constants, or any other identifiable value for the error\n   * type. If falsy, will fall back to `AutonymError.INTERNAL_SERVER_ERROR`.\n   * @param {string} message A human-readable description of the error. It will only be passed to the client in a\n   * response if the code is one of `Autonym.CLIENT_ERRORS`.\n   * @param {object} [data] Additional metadata to store on the error.\n   * @example\n   * const autonymError = new AutonymError(null, 'Something bad happened')\n   * @example\n   * const autonymError = new AutonymError(AutonymError.BAD_REQUEST, 'Something bad happened', { invalid: 'xyz' })\n   */\n  constructor(code, message, data = {}) {\n    const normalizedCode = code || AutonymError.INTERNAL_SERVER_ERROR\n    this._code = normalizedCode\n    this._message = message\n    this._data = data\n    this.stack = new Error(`[${normalizedCode}] ${message}`).stack\n    this._isClientError = false\n    this.isAutonymError = true\n  }\n\n  /**\n   * Gets the error code.\n   * @returns {string} The error code.\n   */\n  getCode() {\n    return this._code\n  }\n\n  /**\n   * Gets the error message.\n   * @returns {string} The error message.\n   */\n  getMessage() {\n    return this._message\n  }\n\n  /**\n   * Gets the HTTP status code for the error based on its code, or falls back to `AutonymError.INTERNAL_SERVER_ERROR`.\n   * @returns {number} The HTTP status code.\n   */\n  getStatus() {\n    return HTTP[this.getCode() || AutonymError.INTERNAL_SERVER_ERROR] || HTTP.INTERNAL_SERVER_ERROR\n  }\n\n  /**\n   * Gets the error metadata.\n   * @returns {object} The error metadata.\n   */\n  getData() {\n    return this._data\n  }\n\n  /**\n   * Gets the data to send in the HTTP response. It will only return the error data and message if the error has\n   * been converted to a client error and its code is one of `Autonym.CLIENT_ERRORS`.\n   * @returns {object} The error payload. At a minimum, this object will have a `message` property.\n   * @example\n   * const err = new AutonymError(AutonymError.INTERNAL_SERVER_ERROR, 'Something bad happened.', { x: 2 })\n   * console.log(err.getPayload()) // { message: 'An internal server error occurred.' }\n   * @example\n   * const err = new AutonymError(AutonymError.BAD_REQUEST, 'Something bad happened.', { x: 2 })\n   * console.log(err.getPayload()) // { x: 2, message: 'Something bad happened.' }\n   */\n  getPayload() {\n    if (this.isClientError()) {\n      return { ...this.getData(), message: this.getMessage() }\n    } else {\n      return { message: 'An internal server error occurred.' }\n    }\n  }\n\n  /**\n   * Creates a copy of this error with a flag on it indicating it is a client error. Any error thrown will by\n   * default be an internal server error, until it is converted to a client error and it has an applicable error code.\n   * @returns {AutonymError} The client error.\n   * @example\n   * const clientError = (new AutonymError(null, 'Something bad happened')).toClientError()\n   * console.log(clientError.isClientError()) // false\n   * console.log(clientError.getPayload()) // { message: 'An internal server error occurred.' }\n   * console.log(clientError.getStatus()) // 500\n   * @example\n   * const clientError = (new AutonymError(AutonymError.BAD_REQUEST, 'Something bad happened')).toClientError()\n   * console.log(clientError.isClientError()) // true\n   * console.log(clientError.getPayload()) // { message: 'Something bad happened' }\n   * console.log(clientError.getStatus()) // 400\n   */\n  toClientError() {\n    const clientError = new AutonymError(this.getCode(), this.getMessage(), this.getData())\n    clientError._isClientError = true\n    return clientError\n  }\n\n  /**\n   * Checks if the error is a client error and its code is one of `Autonym.CLIENT_ERRORS`.\n   * @returns {boolean} Whether it is a client error.\n   */\n  isClientError() {\n    return this._isClientError && AutonymError.CLIENT_ERRORS.includes(this.getCode())\n  }\n}\n",
    "static": true,
    "longname": "/home/circleci/autonym/src/AutonymError.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 51,
    "kind": "class",
    "name": "AutonymError",
    "memberof": "src/AutonymError.js",
    "static": true,
    "longname": "src/AutonymError.js~AutonymError",
    "access": "public",
    "export": true,
    "importPath": "autonym/lib/AutonymError",
    "importStyle": "AutonymError",
    "description": "Wrapper for any error that occurred in a policy or store method.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "BAD_REQUEST",
    "memberof": "src/AutonymError.js~AutonymError",
    "static": true,
    "longname": "src/AutonymError.js~AutonymError.BAD_REQUEST",
    "access": "public",
    "description": "Code indicating the server could not understand the request due to invalid syntax.",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "FORBIDDEN",
    "memberof": "src/AutonymError.js~AutonymError",
    "static": true,
    "longname": "src/AutonymError.js~AutonymError.FORBIDDEN",
    "access": "public",
    "description": "Code indicating the client does not have access rights to the content.",
    "lineNumber": 19,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "METHOD_NOT_ALLOWED",
    "memberof": "src/AutonymError.js~AutonymError",
    "static": true,
    "longname": "src/AutonymError.js~AutonymError.METHOD_NOT_ALLOWED",
    "access": "public",
    "description": "Code indicating the requested store method is not available for this model.",
    "lineNumber": 26,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 55,
    "kind": "member",
    "name": "NOT_FOUND",
    "memberof": "src/AutonymError.js~AutonymError",
    "static": true,
    "longname": "src/AutonymError.js~AutonymError.NOT_FOUND",
    "access": "public",
    "description": "Code indicating the requested resource does not exist.",
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 56,
    "kind": "member",
    "name": "UNAUTHORIZED",
    "memberof": "src/AutonymError.js~AutonymError",
    "static": true,
    "longname": "src/AutonymError.js~AutonymError.UNAUTHORIZED",
    "access": "public",
    "description": "Code indicating the client must be authenticated to perform this action.",
    "lineNumber": 40,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 57,
    "kind": "member",
    "name": "UNPROCESSABLE_ENTITY",
    "memberof": "src/AutonymError.js~AutonymError",
    "static": true,
    "longname": "src/AutonymError.js~AutonymError.UNPROCESSABLE_ENTITY",
    "access": "public",
    "description": "Code indicating the request was improper, i.e. failed schema validation.",
    "lineNumber": 47,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 58,
    "kind": "member",
    "name": "INTERNAL_SERVER_ERROR",
    "memberof": "src/AutonymError.js~AutonymError",
    "static": true,
    "longname": "src/AutonymError.js~AutonymError.INTERNAL_SERVER_ERROR",
    "access": "public",
    "description": "Default. Code indicating an unhandled error occurred while the server was processing the request.",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 59,
    "kind": "member",
    "name": "CLIENT_ERRORS",
    "memberof": "src/AutonymError.js~AutonymError",
    "static": true,
    "longname": "src/AutonymError.js~AutonymError.CLIENT_ERRORS",
    "access": "public",
    "description": "The error codes that indicate client request errors, rather than internal errors.",
    "lineNumber": 61,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "string[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 60,
    "kind": "method",
    "name": "fromError",
    "memberof": "src/AutonymError.js~AutonymError",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/AutonymError.js~AutonymError.fromError",
    "access": "public",
    "description": "Wraps the given error and returns an instance of AutonymError, or returns the given error if it already is an\nAutonymError. If the error object has the property `code`, it will be used as the AutonymError code. If the\nerror object implements a `toJSON` method, its result will be stored as additional data.",
    "examples": [
      "const err = new Error('Something bad happened')\nconst autonymError = AutonymError.fromError(err)\nconsole.log(autonymError.getPayload()) // { message: 'An internal server error occurred.' }",
      "const err = new Error('Something bad happened')\nerr.code = AutonymError.BAD_REQUEST\nconst autonymError = AutonymError.fromError(err)\n// Still internal server error until we call `#toClientError()`\nconsole.log(autonymError.getPayload()) // { message: 'An internal server error occurred.' }"
    ],
    "lineNumber": 87,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{AutonymError} The instance of AutonymError."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Error"
        ],
        "spread": false,
        "optional": false,
        "name": "error",
        "description": "An error object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "AutonymError"
      ],
      "spread": false,
      "description": "The instance of AutonymError."
    }
  },
  {
    "__docId__": 61,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/AutonymError.js~AutonymError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/AutonymError.js~AutonymError#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "const autonymError = new AutonymError(null, 'Something bad happened')",
      "const autonymError = new AutonymError(AutonymError.BAD_REQUEST, 'Something bad happened', { invalid: 'xyz' })"
    ],
    "lineNumber": 112,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "code",
        "description": "One of the error code static constants, or any other identifiable value for the error\ntype. If falsy, will fall back to `AutonymError.INTERNAL_SERVER_ERROR`."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "A human-readable description of the error. It will only be passed to the client in a\nresponse if the code is one of `Autonym.CLIENT_ERRORS`."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "data",
        "description": "Additional metadata to store on the error."
      }
    ]
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "_code",
    "memberof": "src/AutonymError.js~AutonymError",
    "static": false,
    "longname": "src/AutonymError.js~AutonymError#_code",
    "access": "private",
    "description": null,
    "lineNumber": 114,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "_message",
    "memberof": "src/AutonymError.js~AutonymError",
    "static": false,
    "longname": "src/AutonymError.js~AutonymError#_message",
    "access": "private",
    "description": null,
    "lineNumber": 115,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "member",
    "name": "_data",
    "memberof": "src/AutonymError.js~AutonymError",
    "static": false,
    "longname": "src/AutonymError.js~AutonymError#_data",
    "access": "private",
    "description": null,
    "lineNumber": 116,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "member",
    "name": "stack",
    "memberof": "src/AutonymError.js~AutonymError",
    "static": false,
    "longname": "src/AutonymError.js~AutonymError#stack",
    "access": "public",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 66,
    "kind": "member",
    "name": "_isClientError",
    "memberof": "src/AutonymError.js~AutonymError",
    "static": false,
    "longname": "src/AutonymError.js~AutonymError#_isClientError",
    "access": "private",
    "description": null,
    "lineNumber": 118,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "member",
    "name": "isAutonymError",
    "memberof": "src/AutonymError.js~AutonymError",
    "static": false,
    "longname": "src/AutonymError.js~AutonymError#isAutonymError",
    "access": "public",
    "description": null,
    "lineNumber": 119,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "getCode",
    "memberof": "src/AutonymError.js~AutonymError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/AutonymError.js~AutonymError#getCode",
    "access": "public",
    "description": "Gets the error code.",
    "lineNumber": 126,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} The error code."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The error code."
    },
    "params": []
  },
  {
    "__docId__": 69,
    "kind": "method",
    "name": "getMessage",
    "memberof": "src/AutonymError.js~AutonymError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/AutonymError.js~AutonymError#getMessage",
    "access": "public",
    "description": "Gets the error message.",
    "lineNumber": 134,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} The error message."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The error message."
    },
    "params": []
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "getStatus",
    "memberof": "src/AutonymError.js~AutonymError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/AutonymError.js~AutonymError#getStatus",
    "access": "public",
    "description": "Gets the HTTP status code for the error based on its code, or falls back to `AutonymError.INTERNAL_SERVER_ERROR`.",
    "lineNumber": 142,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} The HTTP status code."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The HTTP status code."
    },
    "params": []
  },
  {
    "__docId__": 71,
    "kind": "method",
    "name": "getData",
    "memberof": "src/AutonymError.js~AutonymError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/AutonymError.js~AutonymError#getData",
    "access": "public",
    "description": "Gets the error metadata.",
    "lineNumber": 150,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} The error metadata."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The error metadata."
    },
    "params": []
  },
  {
    "__docId__": 72,
    "kind": "method",
    "name": "getPayload",
    "memberof": "src/AutonymError.js~AutonymError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/AutonymError.js~AutonymError#getPayload",
    "access": "public",
    "description": "Gets the data to send in the HTTP response. It will only return the error data and message if the error has\nbeen converted to a client error and its code is one of `Autonym.CLIENT_ERRORS`.",
    "examples": [
      "const err = new AutonymError(AutonymError.INTERNAL_SERVER_ERROR, 'Something bad happened.', { x: 2 })\nconsole.log(err.getPayload()) // { message: 'An internal server error occurred.' }",
      "const err = new AutonymError(AutonymError.BAD_REQUEST, 'Something bad happened.', { x: 2 })\nconsole.log(err.getPayload()) // { x: 2, message: 'Something bad happened.' }"
    ],
    "lineNumber": 165,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} The error payload. At a minimum, this object will have a `message` property."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The error payload. At a minimum, this object will have a `message` property."
    },
    "params": []
  },
  {
    "__docId__": 73,
    "kind": "method",
    "name": "toClientError",
    "memberof": "src/AutonymError.js~AutonymError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/AutonymError.js~AutonymError#toClientError",
    "access": "public",
    "description": "Creates a copy of this error with a flag on it indicating it is a client error. Any error thrown will by\ndefault be an internal server error, until it is converted to a client error and it has an applicable error code.",
    "examples": [
      "const clientError = (new AutonymError(null, 'Something bad happened')).toClientError()\nconsole.log(clientError.isClientError()) // false\nconsole.log(clientError.getPayload()) // { message: 'An internal server error occurred.' }\nconsole.log(clientError.getStatus()) // 500",
      "const clientError = (new AutonymError(AutonymError.BAD_REQUEST, 'Something bad happened')).toClientError()\nconsole.log(clientError.isClientError()) // true\nconsole.log(clientError.getPayload()) // { message: 'Something bad happened' }\nconsole.log(clientError.getStatus()) // 400"
    ],
    "lineNumber": 188,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{AutonymError} The client error."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "AutonymError"
      ],
      "spread": false,
      "description": "The client error."
    },
    "params": []
  },
  {
    "__docId__": 74,
    "kind": "method",
    "name": "isClientError",
    "memberof": "src/AutonymError.js~AutonymError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/AutonymError.js~AutonymError#isClientError",
    "access": "public",
    "description": "Checks if the error is a client error and its code is one of `Autonym.CLIENT_ERRORS`.",
    "lineNumber": 198,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} Whether it is a client error."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "Whether it is a client error."
    },
    "params": []
  },
  {
    "__docId__": 75,
    "kind": "file",
    "name": "src/Model.js",
    "content": "import { checkForUnrecognizedProperties, cloneInstance, filterToProperties } from './utils'\nimport { cloneDeep, defaultsDeep, forEach, isPlainObject, kebabCase, mapValues, noop, reduce } from 'lodash'\nimport Ajv from 'ajv'\nimport AutonymError from './AutonymError'\nimport { pluralize } from 'inflection'\n\nconst STORE_METHODS = ['create', 'find', 'findOne', 'findOneAndUpdate', 'findOneAndDelete']\nconst POLICY_LIFECYCLE_HOOKS = {\n  create: ['preSchema', 'postSchema', 'preStore', 'postStore'],\n  find: ['preStore', 'postStore'],\n  findOne: ['preStore', 'postStore'],\n  findOneAndUpdate: ['preSchema', 'postSchema', 'preStore', 'postStore'],\n  findOneAndDelete: ['preStore', 'postStore'],\n}\n\n/**\n * Class that defines an entity type for a record accessible in your API.\n */\nexport default class Model {\n  static _normalizeConfig(config) {\n    if (!isPlainObject(config)) {\n      throw new TypeError('config parameter must be a plain object.')\n    }\n\n    const { name } = config\n\n    if (typeof name !== 'string' || name.length === 0) {\n      throw new TypeError('config.name parameter must be a non-empty string.')\n    }\n    if (config.init !== undefined && typeof config.init !== 'function') {\n      throw new TypeError('config.init parameter must be a function or undefined.')\n    }\n    if (config.schema !== null && !isPlainObject(config.schema)) {\n      throw new TypeError('config.schema parameter must be a JSON schema or explicitly null.')\n    }\n    if (config.schema && config.schema.type !== 'object') {\n      throw new TypeError('config.schema.type parameter must be object.')\n    }\n    if (config.optionalUpdateProperties !== undefined && !Array.isArray(config.optionalUpdateProperties)) {\n      throw new TypeError('config.optionalUpdateProperties must be an array or undefined.')\n    }\n    if (config.optionalUpdateProperties) {\n      config.optionalUpdateProperties.forEach((optionalUpdateProperty, i) => {\n        if (\n          typeof optionalUpdateProperty !== 'string' &&\n          (!Array.isArray(optionalUpdateProperty) || !optionalUpdateProperty.every(p => typeof p === 'string'))\n        ) {\n          throw new TypeError(`config.optionalUpdateProperties[${i}] must be a string or array of strings`)\n        }\n      })\n    }\n    if (config.ajvOptions !== undefined && !isPlainObject(config.ajvOptions)) {\n      throw new TypeError('config.ajvOptions parameter must be a plain object or undefined.')\n    }\n    if (config.policies !== undefined && !isPlainObject(config.policies)) {\n      throw new TypeError('config.policies parameter must be a plain object or undefined.')\n    }\n    if (config.store === null || typeof config.store !== 'object') {\n      throw new TypeError('config.store parameter must be an object.')\n    }\n    ;[\n      'create',\n      'find',\n      'findOne',\n      'findOneAndUpdate',\n      'findOneAndDelete',\n      'serialize',\n      'unserialize',\n    ].forEach(method => {\n      if (config.store[method] !== undefined && typeof config.store[method] !== 'function') {\n        throw new TypeError(`config.store.${method} must be a function or undefined.`)\n      }\n    })\n    if (config.route !== undefined && (typeof config.route !== 'string' || config.route === 0)) {\n      throw new TypeError('config.route parameter must be a non-empty string or undefined.')\n    }\n    if (config.initialMeta !== undefined && !isPlainObject(config.initialMeta)) {\n      throw new TypeError('config.initialMeta parameter must be a plain object or undefined.')\n    }\n\n    checkForUnrecognizedProperties('config', config, [\n      'name',\n      'init',\n      'schema',\n      'optionalUpdateProperties',\n      'ajvOptions',\n      'policies',\n      'store',\n      'route',\n    ])\n    checkForUnrecognizedProperties('config.policies', config.policies, STORE_METHODS)\n    forEach(config.policies, (hooks, method) => {\n      if (typeof hooks === 'boolean') {\n        config.policies[method] = { preSchema: hooks, preStore: hooks }\n      } else if (isPlainObject(hooks)) {\n        checkForUnrecognizedProperties(`config.policies.${method}`, hooks, POLICY_LIFECYCLE_HOOKS[method])\n      } else {\n        throw new TypeError(`config.policies.${method} must be a plain object or a boolean.`)\n      }\n    })\n\n    const normalizedConfig = defaultsDeep({}, config, {\n      init: noop,\n      schema: null,\n      optionalUpdateProperties: [],\n      ajvOptions: {\n        allErrors: true,\n        format: 'full',\n        removeAdditional: 'all',\n        useDefaults: true,\n        errorDataPath: 'property',\n      },\n      policies: reduce(\n        POLICY_LIFECYCLE_HOOKS,\n        (policies, hooks, method) => {\n          policies[method] = hooks.reduce((methodHooks, hook) => {\n            methodHooks[hook] = true\n            return methodHooks\n          }, {})\n          return policies\n        },\n        {}\n      ),\n      store: {\n        ...STORE_METHODS.reduce((methods, method) => {\n          methods[method] = () => {\n            throw new AutonymError(AutonymError.METHOD_NOT_ALLOWED, `${method} is not implemented for model \"${name}\".`)\n          }\n          return methods\n        }, {}),\n        serialize: cloneDeep,\n        unserialize: cloneDeep,\n      },\n      route: pluralize(kebabCase(name)),\n      initialMeta: {},\n    })\n\n    const { init } = normalizedConfig\n    normalizedConfig.init = async () => init()\n\n    if (normalizedConfig.schema) {\n      const validateAgainstSchema = new Ajv(normalizedConfig.ajvOptions).compile(normalizedConfig.schema)\n\n      let validateUpdateAgainstSchema = validateAgainstSchema\n      if (normalizedConfig.optionalUpdateProperties.length > 0) {\n        const filteredSchema = cloneDeep(normalizedConfig.schema)\n        normalizedConfig.optionalUpdateProperties.forEach(property => {\n          const dataPath = Array.isArray(property) ? property : [property]\n          const propertyToRemove = dataPath[dataPath.length - 1]\n\n          let object = filteredSchema\n          dataPath.slice(0, -1).forEach(key => {\n            if (!object.properties || !object.properties[key]) {\n              throw new TypeError(`Cannot remove property ${dataPath.join('.')} as it does not exist on the schema.`)\n            }\n            object = object.properties[key]\n          })\n\n          object.required = object.required.filter(prop => prop !== propertyToRemove)\n        })\n        validateUpdateAgainstSchema = new Ajv(normalizedConfig.ajvOptions).compile(filteredSchema)\n      }\n\n      normalizedConfig.validateAgainstSchema = async (data, isUpdate = false) => {\n        const validatedData = cloneDeep(data)\n        const validateFn = isUpdate ? validateUpdateAgainstSchema : validateAgainstSchema\n        if (!validateFn(validatedData)) {\n          throw new AutonymError(AutonymError.UNPROCESSABLE_ENTITY, `Schema validation for model \"${name}\" failed.`, {\n            errors: validateFn.errors,\n          })\n        }\n        return validatedData\n      }\n    } else {\n      normalizedConfig.validateAgainstSchema = async data => data\n    }\n\n    normalizedConfig.store = mapValues(normalizedConfig.store, method => async (...args) =>\n      method.apply(normalizedConfig.store, args)\n    )\n\n    const { serialize, unserialize } = normalizedConfig.store\n    normalizedConfig.store.serialize = async data => serialize(data)\n    normalizedConfig.store.unserialize = async data => unserialize(data)\n\n    return normalizedConfig\n  }\n\n  /**\n   * @param {object} config Configuration.\n   * @param {string} config.name A unique name for the model, like `'user'`.\n   * @param {function(): *|Promise.<*, Error>} [config.init] A function to call when the model is first used.\n   * @param {Schema|null} config.schema A JSON schema to validate data against before passing it to the store\n   * methods, or explicitly `null` to disable schema validation.\n   * @param {Array<string|string[]>} [config.optionalUpdateProperties] A list of properties that are normally required\n   * in the schema but may be optional in a findOneAndUpdate request. This is rarely needed as request data is merged\n   * with the existing record before schema validation occurs, but this can be helpful when properties are converted to\n   * computed properties when saved (e.g. user records that have a passwordHash property and whose password is deleted).\n   * @param {AjvOptions} [config.ajvOptions] Additional options to pass to the Ajv instance.\n   * @param {ModelPolicies} [config.policies] Configuration policies.\n   * @param {Store} config.store Configuration store.\n   * @param {string} [config.route] The route to use for requests of this type of record. Defaults to pluralizing\n   * the `name` property and then converting it to kebab-case.\n   * @param {Meta} [config.initialMeta] The initial value of the `meta` object that is passed to the policies and\n   * store methods.\n   * @example\n   * const Post = new Model({\n   *   name: 'post',\n   *   init: Db.connect(),\n   *   schema: {\n   *     type: 'object',\n   *     properties: {\n   *       title: { type: 'string' },\n   *       body: { type: 'string' },\n   *     },\n   *     require: ['title', 'body'],\n   *   },\n   *   policies: {\n   *     create: {\n   *       preSchema: { and: [getCurrentUserPolicy, canCreatePostPolicy] },\n   *       postSchema: trimPostBodyPolicy,\n   *     },\n   *     find: {\n   *       postStore: addTotalCountHeaderToResponsePolicy,\n   *     },\n   *     findOneAndUpdate: {\n   *       preSchema: { and: [getCurrentUserPolicy, userIsOwnerOfPostPolicy] },\n   *       postSchema: trimPostBodyPolicy,\n   *     },\n   *     findOneAndDelete: {\n   *       preStore: { and: [getCurrentUserPolicy, userIsOwnerOfPostPolicy] },\n   *     },\n   *   },\n   *   store: {\n   *     create: data => Db.insert('posts', data),\n   *     find: () => Db.selectAll('posts'),\n   *     findOne: id => Db.selectOne('posts', { id }),\n   *     findOneAndUpdate: (id, data) => Db.updateWhere('posts', { id }, data),\n   *     findOneAndDelete: id => Db.deleteWhere('posts', { id }),\n   *     serialize: data => mapKeys(data, property => snakeCase(property)),\n   *     unserialize: data => mapKeys(data, columnName => camelCase(columnName)),\n   *   },\n   * })\n   */\n  constructor(config) {\n    this._config = Model._normalizeConfig(config)\n    this._hooks = null\n    this._initialization = null\n  }\n\n  /**\n   * Gets the normalized config.\n   * @returns {object} The normalized config.\n   */\n  getConfig() {\n    return this._config\n  }\n\n  /**\n   * Gets the model name.\n   * @returns {string} The model name.\n   */\n  getName() {\n    return this.getConfig().name\n  }\n\n  /**\n   * Gets the model route.\n   * @returns {string} The model route.\n   */\n  getRoute() {\n    return this.getConfig().route\n  }\n\n  /**\n   * Gets the initial meta.\n   * @returns {Meta} The initial meta.\n   */\n  getInitialMeta() {\n    return this.getConfig().initialMeta\n  }\n\n  /**\n   * Gets the policies.\n   * @returns {ModelPolicies} The policies.\n   */\n  getPolicies() {\n    return this.getConfig().policies\n  }\n\n  /**\n   * Initializes the model if it hasn't been already.\n   * @returns {Promise.<*, Error>} The result of the initialization.\n   */\n  async init() {\n    if (!this._initialization) {\n      this._initialization = this.getConfig().init()\n    }\n    return this._initialization\n  }\n\n  /**\n   * Creates a new record.\n   * @param {Record} data The properties of the record to create.\n   * @param {Meta} [meta] Additional metadata to pass to the store.\n   * @param {array} [hookArgs] *Used internally.* Arguments to pass into the hooks.\n   * @returns {Promise.<Record, AutonymError>} The new record data.\n   * @example\n   * const data = await Post.create({\n   *   title: 'Hello World',\n   *   body: 'This is my first post.',\n   * })\n   *\n   * console.log(data) // { id: '1', title: 'Hello World', body: 'This is my first post.' }\n   */\n  async create(data, meta = {}, hookArgs) {\n    if (!isPlainObject(data)) {\n      throw new TypeError('data parameter must be a plain object.')\n    }\n    if (!isPlainObject(meta)) {\n      throw new TypeError('meta parameter must be a plain object.')\n    }\n\n    return this._callWithHooks(\n      'create',\n      data,\n      async transformedData => {\n        const serializedData = await this.serialize(transformedData)\n        const result = await this.getConfig().store.create(serializedData, meta, transformedData)\n        return this.unserialize(result)\n      },\n      hookArgs\n    )\n  }\n\n  /**\n   * Finds records.\n   * @param {object} [query] The query to filter by.\n   * @param {Meta} [meta] Additional metadata to pass to the store.\n   * @param {array} [hookArgs] *Used internally.* Arguments to pass into the hooks.\n   * @returns {Promise.<Record[], AutonymError>} The data of the found records.\n   * @example\n   * const data = await Post.find()\n   *\n   * console.log(data) // [{ id: '1', title: 'Hello World', body: 'This is my first post.' }]\n   */\n  async find(query, meta = {}, hookArgs) {\n    if (!isPlainObject(meta)) {\n      throw new TypeError('meta parameter must be a plain object.')\n    }\n\n    return this._callWithHooks(\n      'find',\n      null,\n      async () => {\n        const results = await this.getConfig().store.find(query, meta)\n        return Promise.all(results.map(async result => this.unserialize(result)))\n      },\n      hookArgs\n    )\n  }\n\n  /**\n   * Finds a record.\n   * @param {string} id The id of the record to find.\n   * @param {Meta} [meta] Additional metadata to pass to the store.\n   * @param {array} [hookArgs] *Used internally.* Arguments to pass into the hooks.\n   * @returns {Promise.<Record, AutonymError>} The found record data.\n   * @example\n   * const data = await Post.findOne('1')\n   *\n   * console.log(data) // { id: '1', title: 'Hello World', body: 'This is my first post.' }\n   */\n  async findOne(id, meta = {}, hookArgs) {\n    if (typeof id !== 'string' || id.length === 0) {\n      throw new TypeError('id parameter must be a non-empty string.')\n    }\n    if (!isPlainObject(meta)) {\n      throw new TypeError('meta parameter must be a plain object.')\n    }\n\n    return this._callWithHooks(\n      'findOne',\n      null,\n      async () => {\n        const result = await this.getConfig().store.findOne(id, meta)\n        return this.unserialize(result)\n      },\n      hookArgs\n    )\n  }\n\n  /**\n   * Updates a record.\n   * @param {string} id The id of the record to update.\n   * @param {Record} data The properties to update.\n   * @param {Record} [completeData] The complete record with the properties to update merged in. If omitted, it\n   * will be fetched.\n   * @param {Meta} [meta] Additional metadata to pass to the store.\n   * @param {array} [hookArgs] *Used internally.* Arguments to pass into the hooks.\n   * @returns {Promise.<Record, AutonymError>} The updated record data.\n   * @example\n   * const data = await Post.findOneAndUpdate('1', { title: 'Test' })\n   *\n   * console.log(data) // { id: '1', title: 'Test', body: 'This is my first post.' }\n   */\n  async findOneAndUpdate(id, data, completeData = null, meta = {}, hookArgs) {\n    if (typeof id !== 'string' || id.length === 0) {\n      throw new TypeError('id parameter must be a non-empty string.')\n    }\n    if (!isPlainObject(data)) {\n      throw new TypeError('data parameter must be a plain object.')\n    }\n    if (completeData && !isPlainObject(completeData)) {\n      throw new TypeError('completeData parameter must be a plain object or undefined.')\n    }\n    if (!isPlainObject(meta)) {\n      throw new TypeError('meta parameter must be a plain object.')\n    }\n\n    const fetchedCompleteData = completeData || (await this.getConfig().store.findOne(id))\n\n    return this._callWithHooks(\n      'findOneAndUpdate',\n      fetchedCompleteData,\n      async transformedData => {\n        const transformedDataToUpdate = filterToProperties(transformedData, data)\n        const [serializedData, serializedCompleteData] = await Promise.all([\n          this.serialize(transformedDataToUpdate),\n          this.serialize(transformedData),\n        ])\n\n        const result = await this.getConfig().store.findOneAndUpdate(\n          id,\n          serializedData,\n          serializedCompleteData,\n          meta,\n          transformedDataToUpdate,\n          transformedData\n        )\n        return this.unserialize(result)\n      },\n      hookArgs\n    )\n  }\n\n  /**\n   * Deletes a record.\n   * @param {string} id The id of the record to delete.\n   * @param {Meta} [meta] Additional metadata to pass to the store.\n   * @param {array} [hookArgs] *Used internally.* Arguments to pass into the hooks.\n   * @returns {Promise.<object, AutonymError>} An object containing an `id` property set to the deleted record's id.\n   * @example\n   * const data = await Post.findOneAndDelete('1')\n   *\n   * console.log(data) // { id: '1' }\n   */\n  async findOneAndDelete(id, meta = {}, hookArgs) {\n    if (typeof id !== 'string' || id.length === 0) {\n      throw new TypeError('id parameter must be a non-empty string.')\n    }\n    if (!isPlainObject(meta)) {\n      throw new TypeError('meta parameter must be a plain object.')\n    }\n\n    return this._callWithHooks(\n      'findOneAndDelete',\n      null,\n      async () => {\n        await this.getConfig().store.findOneAndDelete(id, meta)\n        const result = { id }\n        return this.unserialize(result)\n      },\n      hookArgs\n    )\n  }\n\n  /**\n   * Serializes the data for a store method.\n   * @param {Record} data The data to serialize.\n   * @returns {Promise.<SerializedRecord, AutonymError>} The serialized data.\n   * @example\n   * const data = await Post.serialize({ authorId: '42' })\n   *\n   * console.log(data) // { author_id: '42' }\n   */\n  async serialize(data) {\n    try {\n      return this.getConfig().store.serialize(data)\n    } catch (err) {\n      throw AutonymError.fromError(err)\n    }\n  }\n\n  /**\n   * Unserializes the data from a store method.\n   * @param {SerializedRecord} data The data to unserialize.\n   * @returns {Promise.<Record, AutonymError>} The unserialized data.\n   * @example\n   * const data = await Post.unserialize({ author_id: '42' })\n   *\n   * console.log(data) // { authorId: '42' }\n   */\n  async unserialize(data) {\n    try {\n      const unserializedData = await this.getConfig().store.unserialize(data)\n      if (unserializedData && unserializedData.id != null) {\n        unserializedData.id = String(unserializedData.id)\n      }\n      return unserializedData\n    } catch (err) {\n      throw AutonymError.fromError(err)\n    }\n  }\n\n  /**\n   * Validates the data against the schema.\n   * @param {Record} data The data to validate. This must be a complete record.\n   * @param {string} [method] One of 'create', 'find', 'findOne', 'findOneAndUpdate', or 'findOneAndDelete', which may\n   * determine different schema restrictions based on the configuration.\n   * @returns {Promise.<Record, AutonymError>} Resolves with the validated data, which has unrecognized properties\n   * filtered out and default values added.\n   * @example\n   * const validatedData = await Post.validateAgainstSchema({ title: 'Hello World', xyz: 123 })\n   *\n   * console.log(validatedData) // { title: 'Hello World' }\n   */\n  async validateAgainstSchema(data, method = null) {\n    return this.getConfig().validateAgainstSchema(data, method === 'findOneAndUpdate')\n  }\n\n  /**\n   * *Used internally.* Creates a copy of the model instance with the given lifecycle hooks added to it.\n   * @param {object} hooks A set of lifecycle hooks.\n   * @returns {Model} A copy of the model instance with the given hooks installed.\n   */\n  withHooks(hooks) {\n    return cloneInstance(this, { _hooks: hooks })\n  }\n\n  async _callWithHooks(method, data, fn, hookArgs = []) {\n    try {\n      await this.init()\n\n      let transformedData = data\n      if (data) {\n        transformedData = await this._callHook(method, 'preSchema', hookArgs, transformedData)\n        transformedData = await this.validateAgainstSchema(transformedData, method)\n        transformedData = await this._callHook(method, 'postSchema', hookArgs, transformedData)\n      }\n\n      transformedData = await this._callHook(method, 'preStore', hookArgs, transformedData)\n      transformedData = await fn(transformedData)\n      transformedData = await this._callHook(method, 'postStore', hookArgs, transformedData)\n\n      return transformedData\n    } catch (err) {\n      throw AutonymError.fromError(err)\n    }\n  }\n\n  async _callHook(method, hook, hookArgs, data) {\n    if (this._hooks) {\n      return this._hooks[method][hook](...hookArgs, data)\n    } else {\n      return data\n    }\n  }\n}\n",
    "static": true,
    "longname": "/home/circleci/autonym/src/Model.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 76,
    "kind": "variable",
    "name": "STORE_METHODS",
    "memberof": "src/Model.js",
    "static": true,
    "longname": "src/Model.js~STORE_METHODS",
    "access": "public",
    "export": false,
    "importPath": "autonym/lib/Model",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 77,
    "kind": "variable",
    "name": "POLICY_LIFECYCLE_HOOKS",
    "memberof": "src/Model.js",
    "static": true,
    "longname": "src/Model.js~POLICY_LIFECYCLE_HOOKS",
    "access": "public",
    "export": false,
    "importPath": "autonym/lib/Model",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "{\"create\": *, \"find\": *, \"findOne\": *, \"findOneAndUpdate\": *, \"findOneAndDelete\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 78,
    "kind": "class",
    "name": "Model",
    "memberof": "src/Model.js",
    "static": true,
    "longname": "src/Model.js~Model",
    "access": "public",
    "export": true,
    "importPath": "autonym/lib/Model",
    "importStyle": "Model",
    "description": "Class that defines an entity type for a record accessible in your API.",
    "lineNumber": 19,
    "interface": false
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "_normalizeConfig",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Model.js~Model._normalizeConfig",
    "access": "private",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Model.js~Model#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "const Post = new Model({\n  name: 'post',\n  init: Db.connect(),\n  schema: {\n    type: 'object',\n    properties: {\n      title: { type: 'string' },\n      body: { type: 'string' },\n    },\n    require: ['title', 'body'],\n  },\n  policies: {\n    create: {\n      preSchema: { and: [getCurrentUserPolicy, canCreatePostPolicy] },\n      postSchema: trimPostBodyPolicy,\n    },\n    find: {\n      postStore: addTotalCountHeaderToResponsePolicy,\n    },\n    findOneAndUpdate: {\n      preSchema: { and: [getCurrentUserPolicy, userIsOwnerOfPostPolicy] },\n      postSchema: trimPostBodyPolicy,\n    },\n    findOneAndDelete: {\n      preStore: { and: [getCurrentUserPolicy, userIsOwnerOfPostPolicy] },\n    },\n  },\n  store: {\n    create: data => Db.insert('posts', data),\n    find: () => Db.selectAll('posts'),\n    findOne: id => Db.selectOne('posts', { id }),\n    findOneAndUpdate: (id, data) => Db.updateWhere('posts', { id }, data),\n    findOneAndDelete: id => Db.deleteWhere('posts', { id }),\n    serialize: data => mapKeys(data, property => snakeCase(property)),\n    unserialize: data => mapKeys(data, columnName => camelCase(columnName)),\n  },\n})"
    ],
    "lineNumber": 245,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": "Configuration."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "config.name",
        "description": "A unique name for the model, like `'user'`."
      },
      {
        "nullable": null,
        "types": [
          "function(): *",
          "Promise.<*, Error>"
        ],
        "spread": false,
        "optional": true,
        "name": "config.init",
        "description": "A function to call when the model is first used."
      },
      {
        "nullable": null,
        "types": [
          "Schema",
          "null"
        ],
        "spread": false,
        "optional": false,
        "name": "config.schema",
        "description": "A JSON schema to validate data against before passing it to the store\nmethods, or explicitly `null` to disable schema validation."
      },
      {
        "nullable": null,
        "types": [
          "Array<string|string[]>"
        ],
        "spread": false,
        "optional": true,
        "name": "config.optionalUpdateProperties",
        "description": "A list of properties that are normally required\nin the schema but may be optional in a findOneAndUpdate request. This is rarely needed as request data is merged\nwith the existing record before schema validation occurs, but this can be helpful when properties are converted to\ncomputed properties when saved (e.g. user records that have a passwordHash property and whose password is deleted)."
      },
      {
        "nullable": null,
        "types": [
          "AjvOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "config.ajvOptions",
        "description": "Additional options to pass to the Ajv instance."
      },
      {
        "nullable": null,
        "types": [
          "ModelPolicies"
        ],
        "spread": false,
        "optional": true,
        "name": "config.policies",
        "description": "Configuration policies."
      },
      {
        "nullable": null,
        "types": [
          "Store"
        ],
        "spread": false,
        "optional": false,
        "name": "config.store",
        "description": "Configuration store."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "config.route",
        "description": "The route to use for requests of this type of record. Defaults to pluralizing\nthe `name` property and then converting it to kebab-case."
      },
      {
        "nullable": null,
        "types": [
          "Meta"
        ],
        "spread": false,
        "optional": true,
        "name": "config.initialMeta",
        "description": "The initial value of the `meta` object that is passed to the policies and\nstore methods."
      }
    ]
  },
  {
    "__docId__": 81,
    "kind": "member",
    "name": "_config",
    "memberof": "src/Model.js~Model",
    "static": false,
    "longname": "src/Model.js~Model#_config",
    "access": "private",
    "description": null,
    "lineNumber": 246,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "member",
    "name": "_hooks",
    "memberof": "src/Model.js~Model",
    "static": false,
    "longname": "src/Model.js~Model#_hooks",
    "access": "private",
    "description": null,
    "lineNumber": 247,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "member",
    "name": "_initialization",
    "memberof": "src/Model.js~Model",
    "static": false,
    "longname": "src/Model.js~Model#_initialization",
    "access": "private",
    "description": null,
    "lineNumber": 248,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "getConfig",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Model.js~Model#getConfig",
    "access": "public",
    "description": "Gets the normalized config.",
    "lineNumber": 255,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} The normalized config."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The normalized config."
    },
    "params": []
  },
  {
    "__docId__": 85,
    "kind": "method",
    "name": "getName",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Model.js~Model#getName",
    "access": "public",
    "description": "Gets the model name.",
    "lineNumber": 263,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} The model name."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The model name."
    },
    "params": []
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "getRoute",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Model.js~Model#getRoute",
    "access": "public",
    "description": "Gets the model route.",
    "lineNumber": 271,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} The model route."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The model route."
    },
    "params": []
  },
  {
    "__docId__": 87,
    "kind": "method",
    "name": "getInitialMeta",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Model.js~Model#getInitialMeta",
    "access": "public",
    "description": "Gets the initial meta.",
    "lineNumber": 279,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Meta} The initial meta."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Meta"
      ],
      "spread": false,
      "description": "The initial meta."
    },
    "params": []
  },
  {
    "__docId__": 88,
    "kind": "method",
    "name": "getPolicies",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Model.js~Model#getPolicies",
    "access": "public",
    "description": "Gets the policies.",
    "lineNumber": 287,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ModelPolicies} The policies."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ModelPolicies"
      ],
      "spread": false,
      "description": "The policies."
    },
    "params": []
  },
  {
    "__docId__": 89,
    "kind": "method",
    "name": "init",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Model.js~Model#init",
    "access": "public",
    "description": "Initializes the model if it hasn't been already.",
    "lineNumber": 295,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<*, Error>} The result of the initialization."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<*, Error>"
      ],
      "spread": false,
      "description": "The result of the initialization."
    },
    "params": []
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "create",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Model.js~Model#create",
    "access": "public",
    "description": "Creates a new record.",
    "examples": [
      "const data = await Post.create({\n  title: 'Hello World',\n  body: 'This is my first post.',\n})\n\nconsole.log(data) // { id: '1', title: 'Hello World', body: 'This is my first post.' }"
    ],
    "lineNumber": 316,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Record, AutonymError>} The new record data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Record"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The properties of the record to create."
      },
      {
        "nullable": null,
        "types": [
          "Meta"
        ],
        "spread": false,
        "optional": true,
        "name": "meta",
        "description": "Additional metadata to pass to the store."
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": true,
        "name": "hookArgs",
        "description": "*Used internally.* Arguments to pass into the hooks."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Record, AutonymError>"
      ],
      "spread": false,
      "description": "The new record data."
    }
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "find",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Model.js~Model#find",
    "access": "public",
    "description": "Finds records.",
    "examples": [
      "const data = await Post.find()\n\nconsole.log(data) // [{ id: '1', title: 'Hello World', body: 'This is my first post.' }]"
    ],
    "lineNumber": 347,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Record[], AutonymError>} The data of the found records."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "query",
        "description": "The query to filter by."
      },
      {
        "nullable": null,
        "types": [
          "Meta"
        ],
        "spread": false,
        "optional": true,
        "name": "meta",
        "description": "Additional metadata to pass to the store."
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": true,
        "name": "hookArgs",
        "description": "*Used internally.* Arguments to pass into the hooks."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Record[], AutonymError>"
      ],
      "spread": false,
      "description": "The data of the found records."
    }
  },
  {
    "__docId__": 93,
    "kind": "method",
    "name": "findOne",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Model.js~Model#findOne",
    "access": "public",
    "description": "Finds a record.",
    "examples": [
      "const data = await Post.findOne('1')\n\nconsole.log(data) // { id: '1', title: 'Hello World', body: 'This is my first post.' }"
    ],
    "lineNumber": 374,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Record, AutonymError>} The found record data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The id of the record to find."
      },
      {
        "nullable": null,
        "types": [
          "Meta"
        ],
        "spread": false,
        "optional": true,
        "name": "meta",
        "description": "Additional metadata to pass to the store."
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": true,
        "name": "hookArgs",
        "description": "*Used internally.* Arguments to pass into the hooks."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Record, AutonymError>"
      ],
      "spread": false,
      "description": "The found record data."
    }
  },
  {
    "__docId__": 94,
    "kind": "method",
    "name": "findOneAndUpdate",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Model.js~Model#findOneAndUpdate",
    "access": "public",
    "description": "Updates a record.",
    "examples": [
      "const data = await Post.findOneAndUpdate('1', { title: 'Test' })\n\nconsole.log(data) // { id: '1', title: 'Test', body: 'This is my first post.' }"
    ],
    "lineNumber": 407,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Record, AutonymError>} The updated record data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The id of the record to update."
      },
      {
        "nullable": null,
        "types": [
          "Record"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The properties to update."
      },
      {
        "nullable": null,
        "types": [
          "Record"
        ],
        "spread": false,
        "optional": true,
        "name": "completeData",
        "description": "The complete record with the properties to update merged in. If omitted, it\nwill be fetched."
      },
      {
        "nullable": null,
        "types": [
          "Meta"
        ],
        "spread": false,
        "optional": true,
        "name": "meta",
        "description": "Additional metadata to pass to the store."
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": true,
        "name": "hookArgs",
        "description": "*Used internally.* Arguments to pass into the hooks."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Record, AutonymError>"
      ],
      "spread": false,
      "description": "The updated record data."
    }
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "findOneAndDelete",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Model.js~Model#findOneAndDelete",
    "access": "public",
    "description": "Deletes a record.",
    "examples": [
      "const data = await Post.findOneAndDelete('1')\n\nconsole.log(data) // { id: '1' }"
    ],
    "lineNumber": 458,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<object, AutonymError>} An object containing an `id` property set to the deleted record's id."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The id of the record to delete."
      },
      {
        "nullable": null,
        "types": [
          "Meta"
        ],
        "spread": false,
        "optional": true,
        "name": "meta",
        "description": "Additional metadata to pass to the store."
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": true,
        "name": "hookArgs",
        "description": "*Used internally.* Arguments to pass into the hooks."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<object, AutonymError>"
      ],
      "spread": false,
      "description": "An object containing an `id` property set to the deleted record's id."
    }
  },
  {
    "__docId__": 96,
    "kind": "method",
    "name": "serialize",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Model.js~Model#serialize",
    "access": "public",
    "description": "Serializes the data for a store method.",
    "examples": [
      "const data = await Post.serialize({ authorId: '42' })\n\nconsole.log(data) // { author_id: '42' }"
    ],
    "lineNumber": 487,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<SerializedRecord, AutonymError>} The serialized data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Record"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The data to serialize."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<SerializedRecord, AutonymError>"
      ],
      "spread": false,
      "description": "The serialized data."
    }
  },
  {
    "__docId__": 97,
    "kind": "method",
    "name": "unserialize",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Model.js~Model#unserialize",
    "access": "public",
    "description": "Unserializes the data from a store method.",
    "examples": [
      "const data = await Post.unserialize({ author_id: '42' })\n\nconsole.log(data) // { authorId: '42' }"
    ],
    "lineNumber": 504,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Record, AutonymError>} The unserialized data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "SerializedRecord"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The data to unserialize."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Record, AutonymError>"
      ],
      "spread": false,
      "description": "The unserialized data."
    }
  },
  {
    "__docId__": 98,
    "kind": "method",
    "name": "validateAgainstSchema",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Model.js~Model#validateAgainstSchema",
    "access": "public",
    "description": "Validates the data against the schema.",
    "examples": [
      "const validatedData = await Post.validateAgainstSchema({ title: 'Hello World', xyz: 123 })\n\nconsole.log(validatedData) // { title: 'Hello World' }"
    ],
    "lineNumber": 528,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Record, AutonymError>} Resolves with the validated data, which has unrecognized properties\nfiltered out and default values added."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Record"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The data to validate. This must be a complete record."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "method",
        "description": "One of 'create', 'find', 'findOne', 'findOneAndUpdate', or 'findOneAndDelete', which may\ndetermine different schema restrictions based on the configuration."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Record, AutonymError>"
      ],
      "spread": false,
      "description": "Resolves with the validated data, which has unrecognized properties\nfiltered out and default values added."
    }
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "withHooks",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Model.js~Model#withHooks",
    "access": "public",
    "description": "*Used internally.* Creates a copy of the model instance with the given lifecycle hooks added to it.",
    "lineNumber": 537,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Model} A copy of the model instance with the given hooks installed."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "hooks",
        "description": "A set of lifecycle hooks."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Model"
      ],
      "spread": false,
      "description": "A copy of the model instance with the given hooks installed."
    }
  },
  {
    "__docId__": 100,
    "kind": "method",
    "name": "_callWithHooks",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Model.js~Model#_callWithHooks",
    "access": "private",
    "description": null,
    "lineNumber": 541,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "method",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "fn",
        "types": [
          "*"
        ]
      },
      {
        "name": "hookArgs",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "method",
    "name": "_callHook",
    "memberof": "src/Model.js~Model",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Model.js~Model#_callHook",
    "access": "private",
    "description": null,
    "lineNumber": 562,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "method",
        "types": [
          "*"
        ]
      },
      {
        "name": "hook",
        "types": [
          "*"
        ]
      },
      {
        "name": "hookArgs",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "file",
    "name": "src/Req.js",
    "content": "import { cloneDeep, defaultsDeep, isPlainObject } from 'lodash'\nimport assignDeep from 'assign-deep'\nimport { deleteUndefineds } from './utils'\n\n/**\n * A wrapper for the request object with helper methods and access to Autonym model data.\n */\nexport default class Req {\n  /**\n   * @param {http.IncomingMessage} raw The raw IncomingMessage object.\n   * @param {Model} model The Autonym model instance.\n   * @param {Meta} meta The meta object aggregated by policies during the request.\n   * @example\n   * const req = new AutonymReq(request, Post, meta)\n   */\n  constructor(raw, model, meta) {\n    raw.autonym = this\n    raw.autonymMeta = meta\n\n    this._raw = raw\n    this._model = model\n    this._data = this.hasBody() ? cloneDeep(raw.body) : null\n    this._originalData = null\n    this._isValidated = false\n  }\n\n  /**\n   * Gets the raw request.\n   * @returns {http.IncomingMessage} The raw request.\n   */\n  getRaw() {\n    return this._raw\n  }\n\n  /**\n   * Gets the request payload.\n   * @returns {Record} The data.\n   * @throws {ReferenceError} If the request does not have a body.\n   */\n  getData() {\n    if (!this.hasBody()) {\n      throw new ReferenceError('Cannot get request data from a request without a body.')\n    }\n    return this._data\n  }\n\n  /**\n   * Merges the request data with the given data, without modifying the original request.\n   * @param {Record} data The new properties to set.\n   * @param {boolean} [replace] If true, replaces the data on the response instead of merging it.\n   * @returns {void}\n   * @throws {ReferenceError} If the request does not have a body.\n   * @example\n   * console.log(req.getData()) // { title: 'Hello World' }\n   * req.setData({ name: 'Test' })\n   * console.log(req.getData()) // { name: 'Test', title: 'Hello World' }\n   * @example\n   * console.log(req.getData()) // { title: 'Hello World' }\n   * req.setData({ name: 'Test' }, true)\n   * console.log(req.getData()) // { name: 'Test' }\n   */\n  setData(data, replace = false) {\n    if (!isPlainObject(data)) {\n      throw new TypeError('The data must be a plain object.')\n    }\n    if (!this.hasBody()) {\n      throw new ReferenceError('Cannot set request data on a request without a body.')\n    }\n\n    if (replace) {\n      this._data = data\n    } else {\n      assignDeep(this._data, data)\n    }\n\n    deleteUndefineds(this._data)\n  }\n\n  /**\n   * Gets the data that was originally on the request body.\n   * @returns {Record} The data.\n   * @throws {ReferenceError} If the request does not have a body.\n   */\n  getRequestData() {\n    if (!this.hasBody()) {\n      throw new ReferenceError('Cannot get request data from a request without a body.')\n    }\n    return this.getRaw().body\n  }\n\n  /**\n   * For update queries, gets the data of the original record to update. For create queries, gets an empty object.\n   * @returns {Promise.<Record, AutonymError>} The original record data.\n   * @throws {ReferenceError} If the request is not a create or update request.\n   * @example\n   * console.log(req.getData()) // { title: 'Test' }\n   * const originalData = await req.getOriginalData()\n   * console.log(originalData) // { title: 'Hello World', body: 'This is my first post.' }\n   */\n  async getOriginalData() {\n    if (!this.isWriting()) {\n      throw new ReferenceError('Cannot get original data on a request without a body.')\n    }\n    if (!this._originalData) {\n      this._originalData = this.isCreating() ? {} : this.getModel().findOne(this.getId())\n    }\n    return this._originalData\n  }\n\n  /**\n   * Gets the result of merging the original data (see `#getOriginalData`) with the request data.\n   * @returns {Promise.<Record, AutonymError>} The merged data.\n   * @example\n   * console.log(req.getData()) // { title: 'Test' }\n   * const originalData = await req.getCompleteData()\n   * console.log(originalData) // { title: 'Test', body: 'This is my first post.' }\n   */\n  async getCompleteData() {\n    const originalData = await this.getOriginalData()\n    return defaultsDeep({}, this.getData(), originalData)\n  }\n\n  /**\n   * Gets the model instance.\n   * @returns {Model} The model.\n   */\n  getModel() {\n    return this._model\n  }\n\n  /**\n   * Gets the request query.\n   * @returns {object} The query.\n   */\n  getQuery() {\n    return this.getRaw().query\n  }\n\n  /**\n   * Gets the requested record id.\n   * @returns {string} The record id.\n   * @throws {ReferenceError} If it is a create or find request.\n   */\n  getId() {\n    if (!this.hasId()) {\n      throw new ReferenceError('Cannot get id of request that creates or finds multiple.')\n    }\n    return this.getRaw().params.id\n  }\n\n  /**\n   * Gets the given header.\n   * @param {string} header The header to find.\n   * @returns {string|undefined} The header value.\n   */\n  getHeader(header) {\n    return this.getRaw().get(header)\n  }\n\n  /**\n   * Whether this step is occurring with safe data, i.e. the data has been validated, filtered, and populated with\n   * defaults.\n   * @returns {boolean} True if it has passed the preSchema and validateAgainstSchema steps.\n   */\n  isValidated() {\n    return this._isValidated\n  }\n\n  /**\n   * Whether this is a create request.\n   * @returns {boolean} True if it is a create request.\n   */\n  isCreating() {\n    return this.getRaw().method === 'POST'\n  }\n\n  /**\n   * Whether this is a find request.\n   * @returns {boolean} True if it is a find request.\n   */\n  isFinding() {\n    return this.getRaw().method === 'GET' && !this.getRaw().params.id\n  }\n\n  /**\n   * Whether this is a findOne request.\n   * @returns {boolean} True if it is a findOne request.\n   */\n  isFindingOne() {\n    return this.getRaw().method === 'GET' && this.getRaw().params.id\n  }\n\n  /**\n   * Whether this is a findOneAndUpdate request.\n   * @returns {boolean} True if it is a findOneAndUpdate request.\n   */\n  isFindingOneAndUpdating() {\n    return this.getRaw().method === 'PATCH' || this.getRaw().method === 'PUT'\n  }\n\n  /**\n   * Whether this is a findOneAndDelete request.\n   * @returns {boolean} True if it is a findOneAndDelete request.\n   */\n  isFindingOneAndDeleting() {\n    return this.getRaw().method === 'DELETE'\n  }\n\n  /**\n   * Whether this is a readonly request to fetch data.\n   * @returns {boolean} True if it is a find or findOne request.\n   */\n  isGetting() {\n    return this.isFinding() || this.isFindingOne()\n  }\n\n  /**\n   * Whether this is a request that will return response data.\n   * @returns {boolean} True if it is a create, find, findOne, or findOneAndUpdate request.\n   */\n  isReading() {\n    return !this.isFindingOneAndDeleting()\n  }\n\n  /**\n   * Whether this request has a body.\n   * @returns {boolean} True if it is a create or findOneAndUpdate request.\n   */\n  hasBody() {\n    return this.isCreating() || this.isFindingOneAndUpdating()\n  }\n\n  /**\n   * Whether this is a request that will modify the data store.\n   * @returns {boolean} True if it is a create, findOneAndUpdate, or findOneAndDelete request.\n   */\n  isWriting() {\n    return this.hasBody() || this.isFindingOneAndDeleting()\n  }\n\n  /**\n   * Whether this is a request for a particular record.\n   * @returns {boolean} True if it is a findOne, findOneAndUpdate, or findOneAndDelete request.\n   */\n  hasId() {\n    return this.isFindingOne() || this.isFindingOneAndUpdating() || this.isFindingOneAndDeleting()\n  }\n}\n",
    "static": true,
    "longname": "/home/circleci/autonym/src/Req.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 103,
    "kind": "class",
    "name": "Req",
    "memberof": "src/Req.js",
    "static": true,
    "longname": "src/Req.js~Req",
    "access": "public",
    "export": true,
    "importPath": "autonym/lib/Req",
    "importStyle": "Req",
    "description": "A wrapper for the request object with helper methods and access to Autonym model data.",
    "lineNumber": 8,
    "interface": false
  },
  {
    "__docId__": 104,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "const req = new AutonymReq(request, Post, meta)"
    ],
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "http.IncomingMessage"
        ],
        "spread": false,
        "optional": false,
        "name": "raw",
        "description": "The raw IncomingMessage object."
      },
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "model",
        "description": "The Autonym model instance."
      },
      {
        "nullable": null,
        "types": [
          "Meta"
        ],
        "spread": false,
        "optional": false,
        "name": "meta",
        "description": "The meta object aggregated by policies during the request."
      }
    ]
  },
  {
    "__docId__": 105,
    "kind": "member",
    "name": "_raw",
    "memberof": "src/Req.js~Req",
    "static": false,
    "longname": "src/Req.js~Req#_raw",
    "access": "private",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "member",
    "name": "_model",
    "memberof": "src/Req.js~Req",
    "static": false,
    "longname": "src/Req.js~Req#_model",
    "access": "private",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "member",
    "name": "_data",
    "memberof": "src/Req.js~Req",
    "static": false,
    "longname": "src/Req.js~Req#_data",
    "access": "private",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 108,
    "kind": "member",
    "name": "_originalData",
    "memberof": "src/Req.js~Req",
    "static": false,
    "longname": "src/Req.js~Req#_originalData",
    "access": "private",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "member",
    "name": "_isValidated",
    "memberof": "src/Req.js~Req",
    "static": false,
    "longname": "src/Req.js~Req#_isValidated",
    "access": "private",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "getRaw",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#getRaw",
    "access": "public",
    "description": "Gets the raw request.",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{http.IncomingMessage} The raw request."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "http.IncomingMessage"
      ],
      "spread": false,
      "description": "The raw request."
    },
    "params": []
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "getData",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#getData",
    "access": "public",
    "description": "Gets the request payload.",
    "lineNumber": 40,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Record} The data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Record"
      ],
      "spread": false,
      "description": "The data."
    },
    "throws": [
      {
        "types": [
          "ReferenceError"
        ],
        "description": "If the request does not have a body."
      }
    ],
    "params": []
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "setData",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#setData",
    "access": "public",
    "description": "Merges the request data with the given data, without modifying the original request.",
    "examples": [
      "console.log(req.getData()) // { title: 'Hello World' }\nreq.setData({ name: 'Test' })\nconsole.log(req.getData()) // { name: 'Test', title: 'Hello World' }",
      "console.log(req.getData()) // { title: 'Hello World' }\nreq.setData({ name: 'Test' }, true)\nconsole.log(req.getData()) // { name: 'Test' }"
    ],
    "lineNumber": 62,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{void}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Record"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The new properties to set."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "replace",
        "description": "If true, replaces the data on the response instead of merging it."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "void"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "ReferenceError"
        ],
        "description": "If the request does not have a body."
      }
    ]
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "getRequestData",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#getRequestData",
    "access": "public",
    "description": "Gets the data that was originally on the request body.",
    "lineNumber": 84,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Record} The data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Record"
      ],
      "spread": false,
      "description": "The data."
    },
    "throws": [
      {
        "types": [
          "ReferenceError"
        ],
        "description": "If the request does not have a body."
      }
    ],
    "params": []
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "getOriginalData",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Req.js~Req#getOriginalData",
    "access": "public",
    "description": "For update queries, gets the data of the original record to update. For create queries, gets an empty object.",
    "examples": [
      "console.log(req.getData()) // { title: 'Test' }\nconst originalData = await req.getOriginalData()\nconsole.log(originalData) // { title: 'Hello World', body: 'This is my first post.' }"
    ],
    "lineNumber": 100,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Record, AutonymError>} The original record data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Record, AutonymError>"
      ],
      "spread": false,
      "description": "The original record data."
    },
    "throws": [
      {
        "types": [
          "ReferenceError"
        ],
        "description": "If the request is not a create or update request."
      }
    ],
    "params": []
  },
  {
    "__docId__": 117,
    "kind": "method",
    "name": "getCompleteData",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Req.js~Req#getCompleteData",
    "access": "public",
    "description": "Gets the result of merging the original data (see `#getOriginalData`) with the request data.",
    "examples": [
      "console.log(req.getData()) // { title: 'Test' }\nconst originalData = await req.getCompleteData()\nconsole.log(originalData) // { title: 'Test', body: 'This is my first post.' }"
    ],
    "lineNumber": 118,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Record, AutonymError>} The merged data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Record, AutonymError>"
      ],
      "spread": false,
      "description": "The merged data."
    },
    "params": []
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "getModel",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#getModel",
    "access": "public",
    "description": "Gets the model instance.",
    "lineNumber": 127,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Model} The model."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Model"
      ],
      "spread": false,
      "description": "The model."
    },
    "params": []
  },
  {
    "__docId__": 119,
    "kind": "method",
    "name": "getQuery",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#getQuery",
    "access": "public",
    "description": "Gets the request query.",
    "lineNumber": 135,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} The query."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The query."
    },
    "params": []
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "getId",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#getId",
    "access": "public",
    "description": "Gets the requested record id.",
    "lineNumber": 144,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} The record id."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The record id."
    },
    "throws": [
      {
        "types": [
          "ReferenceError"
        ],
        "description": "If it is a create or find request."
      }
    ],
    "params": []
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "getHeader",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#getHeader",
    "access": "public",
    "description": "Gets the given header.",
    "lineNumber": 156,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string|undefined} The header value."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "header",
        "description": "The header to find."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string",
        "undefined"
      ],
      "spread": false,
      "description": "The header value."
    }
  },
  {
    "__docId__": 122,
    "kind": "method",
    "name": "isValidated",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#isValidated",
    "access": "public",
    "description": "Whether this step is occurring with safe data, i.e. the data has been validated, filtered, and populated with\ndefaults.",
    "lineNumber": 165,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if it has passed the preSchema and validateAgainstSchema steps."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if it has passed the preSchema and validateAgainstSchema steps."
    },
    "params": []
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "isCreating",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#isCreating",
    "access": "public",
    "description": "Whether this is a create request.",
    "lineNumber": 173,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if it is a create request."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if it is a create request."
    },
    "params": []
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "isFinding",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#isFinding",
    "access": "public",
    "description": "Whether this is a find request.",
    "lineNumber": 181,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if it is a find request."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if it is a find request."
    },
    "params": []
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "isFindingOne",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#isFindingOne",
    "access": "public",
    "description": "Whether this is a findOne request.",
    "lineNumber": 189,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if it is a findOne request."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if it is a findOne request."
    },
    "params": []
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "isFindingOneAndUpdating",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#isFindingOneAndUpdating",
    "access": "public",
    "description": "Whether this is a findOneAndUpdate request.",
    "lineNumber": 197,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if it is a findOneAndUpdate request."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if it is a findOneAndUpdate request."
    },
    "params": []
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "isFindingOneAndDeleting",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#isFindingOneAndDeleting",
    "access": "public",
    "description": "Whether this is a findOneAndDelete request.",
    "lineNumber": 205,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if it is a findOneAndDelete request."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if it is a findOneAndDelete request."
    },
    "params": []
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "isGetting",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#isGetting",
    "access": "public",
    "description": "Whether this is a readonly request to fetch data.",
    "lineNumber": 213,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if it is a find or findOne request."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if it is a find or findOne request."
    },
    "params": []
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "isReading",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#isReading",
    "access": "public",
    "description": "Whether this is a request that will return response data.",
    "lineNumber": 221,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if it is a create, find, findOne, or findOneAndUpdate request."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if it is a create, find, findOne, or findOneAndUpdate request."
    },
    "params": []
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "hasBody",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#hasBody",
    "access": "public",
    "description": "Whether this request has a body.",
    "lineNumber": 229,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if it is a create or findOneAndUpdate request."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if it is a create or findOneAndUpdate request."
    },
    "params": []
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "isWriting",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#isWriting",
    "access": "public",
    "description": "Whether this is a request that will modify the data store.",
    "lineNumber": 237,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if it is a create, findOneAndUpdate, or findOneAndDelete request."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if it is a create, findOneAndUpdate, or findOneAndDelete request."
    },
    "params": []
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "hasId",
    "memberof": "src/Req.js~Req",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Req.js~Req#hasId",
    "access": "public",
    "description": "Whether this is a request for a particular record.",
    "lineNumber": 245,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if it is a findOne, findOneAndUpdate, or findOneAndDelete request."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if it is a findOne, findOneAndUpdate, or findOneAndDelete request."
    },
    "params": []
  },
  {
    "__docId__": 133,
    "kind": "file",
    "name": "src/Res.js",
    "content": "import HTTP from 'http-status-codes'\nimport assignDeep from 'assign-deep'\nimport { deleteUndefineds } from './utils'\nimport { isPlainObject } from 'lodash'\n\n/**\n * A wrapper for the response object with helper methods and access to Autonym model data.\n */\nexport default class Res {\n  /**\n   * The status code for successful find, findOne, findOneAndUpdate, and findOneAndDelete calls.\n   * @type {number}\n   * @constant\n   */\n  static OK = HTTP.OK\n\n  /**\n   * The status code for successful create calls.\n   * @type {number}\n   * @constant\n   */\n  static CREATED = HTTP.CREATED\n\n  /**\n   * @param {http.ServerResponse} raw The raw ServerResponse object.\n   * @param {Model} model The Autonym model instance.\n   * @param {Meta} meta The meta object aggregated by policies during the request.\n   * @example\n   * const res = new AutonymRes(response, Post, meta)\n   */\n  constructor(raw, model, meta) {\n    raw.autonym = this\n    raw.autonymMeta = meta\n\n    this._raw = raw\n    this._model = model\n    this._data = null\n    this._status = null\n    this._isPopulated = false\n  }\n\n  /**\n   * Gets the raw response.\n   * @returns {http.ServerResponse} The raw response.\n   */\n  getRaw() {\n    return this._raw\n  }\n\n  /**\n   * Gets the data currently set for the response body.\n   * @returns {Record} The data.\n   * @throws {ReferenceError} If the store method has not been called yet.\n   */\n  getData() {\n    if (!this.isPopulated()) {\n      throw new ReferenceError('Cannot get response data before store method has been called.')\n    }\n    return this._data\n  }\n\n  /**\n   * Merges the currently set response data with the given data.\n   * @param {Record} data The new properties to set.\n   * @param {boolean} [replace] If true, replaces the data on the response instead of merging it.\n   * @returns {void}\n   * @throws {ReferenceError} If the store method has not been called yet.\n   * @example\n   * console.log(res.getData()) // { title: 'Hello World' }\n   * res.setData({ name: 'Test' })\n   * console.log(res.getData()) // { name: 'Test', title: 'Hello World' }\n   * @example\n   * console.log(res.getData()) // { title: 'Hello World' }\n   * res.setData({ name: 'Test' }, true)\n   * console.log(res.getData()) // { name: 'Test' }\n   */\n  setData(data, replace = false) {\n    if (!this.isPopulated()) {\n      throw new ReferenceError('Cannot set response data before store method has been called.')\n    }\n\n    if (replace) {\n      this._data = data\n      deleteUndefineds(this._data)\n    } else if (Array.isArray(this._data)) {\n      if (!Array.isArray(data)) {\n        throw new TypeError('The data must be an array.')\n      }\n\n      this._data.forEach((record, i) => {\n        assignDeep(record, data[i] || {})\n        deleteUndefineds(record)\n      })\n    } else {\n      if (!isPlainObject(data)) {\n        throw new TypeError('The data must be a plain object.')\n      }\n      this._data = assignDeep(this._data, data)\n      deleteUndefineds(this._data)\n    }\n  }\n\n  /**\n   * Gets the currently set status code.\n   * @returns {number|null} The status code.\n   */\n  getStatus() {\n    return this._status\n  }\n\n  /**\n   * Sets the status code.\n   * @param {number} status The status code.\n   * @returns {void}\n   */\n  setStatus(status) {\n    if (typeof status !== 'number') {\n      throw new TypeError('The status must be a number.')\n    }\n    this._status = status\n  }\n\n  /**\n   * Gets the model instance.\n   * @returns {Model} The model.\n   */\n  getModel() {\n    return this._model\n  }\n\n  /**\n   * Gets the given header.\n   * @param {string} header The header to find.\n   * @returns {string|undefined} The header value.\n   */\n  getHeader(header) {\n    return this.getRaw().get(header)\n  }\n\n  /**\n   * Sets the given header.\n   * @param {string} header The header to set.\n   * @param {string} value The value to set to.\n   * @returns {void}\n   */\n  setHeader(header, value) {\n    if (typeof header !== 'string') {\n      throw new TypeError('The header must be a string')\n    }\n    if (typeof value !== 'string') {\n      throw new TypeError('The value must be a string')\n    }\n    return this.getRaw().set(header, value)\n  }\n\n  /**\n   * Whether the store method has populated the response data yet.\n   * @returns {boolean} True if the store method has been called.\n   */\n  isPopulated() {\n    return this._isPopulated\n  }\n\n  /**\n   * Whether the response has been sent to the client.\n   * @returns {boolean} True if the response has been sent.\n   */\n  isSent() {\n    return this.getRaw().headerSent\n  }\n}\n",
    "static": true,
    "longname": "/home/circleci/autonym/src/Res.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 134,
    "kind": "class",
    "name": "Res",
    "memberof": "src/Res.js",
    "static": true,
    "longname": "src/Res.js~Res",
    "access": "public",
    "export": true,
    "importPath": "autonym/lib/Res",
    "importStyle": "Res",
    "description": "A wrapper for the response object with helper methods and access to Autonym model data.",
    "lineNumber": 9,
    "interface": false
  },
  {
    "__docId__": 135,
    "kind": "member",
    "name": "OK",
    "memberof": "src/Res.js~Res",
    "static": true,
    "longname": "src/Res.js~Res.OK",
    "access": "public",
    "description": "The status code for successful find, findOne, findOneAndUpdate, and findOneAndDelete calls.",
    "lineNumber": 15,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 136,
    "kind": "member",
    "name": "CREATED",
    "memberof": "src/Res.js~Res",
    "static": true,
    "longname": "src/Res.js~Res.CREATED",
    "access": "public",
    "description": "The status code for successful create calls.",
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 137,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Res.js~Res",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Res.js~Res#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "const res = new AutonymRes(response, Post, meta)"
    ],
    "lineNumber": 31,
    "params": [
      {
        "nullable": null,
        "types": [
          "http.ServerResponse"
        ],
        "spread": false,
        "optional": false,
        "name": "raw",
        "description": "The raw ServerResponse object."
      },
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "model",
        "description": "The Autonym model instance."
      },
      {
        "nullable": null,
        "types": [
          "Meta"
        ],
        "spread": false,
        "optional": false,
        "name": "meta",
        "description": "The meta object aggregated by policies during the request."
      }
    ]
  },
  {
    "__docId__": 138,
    "kind": "member",
    "name": "_raw",
    "memberof": "src/Res.js~Res",
    "static": false,
    "longname": "src/Res.js~Res#_raw",
    "access": "private",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 139,
    "kind": "member",
    "name": "_model",
    "memberof": "src/Res.js~Res",
    "static": false,
    "longname": "src/Res.js~Res#_model",
    "access": "private",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "member",
    "name": "_data",
    "memberof": "src/Res.js~Res",
    "static": false,
    "longname": "src/Res.js~Res#_data",
    "access": "private",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "member",
    "name": "_status",
    "memberof": "src/Res.js~Res",
    "static": false,
    "longname": "src/Res.js~Res#_status",
    "access": "private",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "member",
    "name": "_isPopulated",
    "memberof": "src/Res.js~Res",
    "static": false,
    "longname": "src/Res.js~Res#_isPopulated",
    "access": "private",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "method",
    "name": "getRaw",
    "memberof": "src/Res.js~Res",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Res.js~Res#getRaw",
    "access": "public",
    "description": "Gets the raw response.",
    "lineNumber": 46,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{http.ServerResponse} The raw response."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "http.ServerResponse"
      ],
      "spread": false,
      "description": "The raw response."
    },
    "params": []
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "getData",
    "memberof": "src/Res.js~Res",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Res.js~Res#getData",
    "access": "public",
    "description": "Gets the data currently set for the response body.",
    "lineNumber": 55,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Record} The data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Record"
      ],
      "spread": false,
      "description": "The data."
    },
    "throws": [
      {
        "types": [
          "ReferenceError"
        ],
        "description": "If the store method has not been called yet."
      }
    ],
    "params": []
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "setData",
    "memberof": "src/Res.js~Res",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Res.js~Res#setData",
    "access": "public",
    "description": "Merges the currently set response data with the given data.",
    "examples": [
      "console.log(res.getData()) // { title: 'Hello World' }\nres.setData({ name: 'Test' })\nconsole.log(res.getData()) // { name: 'Test', title: 'Hello World' }",
      "console.log(res.getData()) // { title: 'Hello World' }\nres.setData({ name: 'Test' }, true)\nconsole.log(res.getData()) // { name: 'Test' }"
    ],
    "lineNumber": 77,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{void}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Record"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The new properties to set."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "replace",
        "description": "If true, replaces the data on the response instead of merging it."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "void"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "ReferenceError"
        ],
        "description": "If the store method has not been called yet."
      }
    ]
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "getStatus",
    "memberof": "src/Res.js~Res",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Res.js~Res#getStatus",
    "access": "public",
    "description": "Gets the currently set status code.",
    "lineNumber": 107,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number|null} The status code."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number",
        "null"
      ],
      "spread": false,
      "description": "The status code."
    },
    "params": []
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "setStatus",
    "memberof": "src/Res.js~Res",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Res.js~Res#setStatus",
    "access": "public",
    "description": "Sets the status code.",
    "lineNumber": 116,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{void}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "status",
        "description": "The status code."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "void"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 151,
    "kind": "method",
    "name": "getModel",
    "memberof": "src/Res.js~Res",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Res.js~Res#getModel",
    "access": "public",
    "description": "Gets the model instance.",
    "lineNumber": 127,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Model} The model."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Model"
      ],
      "spread": false,
      "description": "The model."
    },
    "params": []
  },
  {
    "__docId__": 152,
    "kind": "method",
    "name": "getHeader",
    "memberof": "src/Res.js~Res",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Res.js~Res#getHeader",
    "access": "public",
    "description": "Gets the given header.",
    "lineNumber": 136,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string|undefined} The header value."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "header",
        "description": "The header to find."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string",
        "undefined"
      ],
      "spread": false,
      "description": "The header value."
    }
  },
  {
    "__docId__": 153,
    "kind": "method",
    "name": "setHeader",
    "memberof": "src/Res.js~Res",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Res.js~Res#setHeader",
    "access": "public",
    "description": "Sets the given header.",
    "lineNumber": 146,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{void}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "header",
        "description": "The header to set."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The value to set to."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "void"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 154,
    "kind": "method",
    "name": "isPopulated",
    "memberof": "src/Res.js~Res",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Res.js~Res#isPopulated",
    "access": "public",
    "description": "Whether the store method has populated the response data yet.",
    "lineNumber": 160,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if the store method has been called."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if the store method has been called."
    },
    "params": []
  },
  {
    "__docId__": 155,
    "kind": "method",
    "name": "isSent",
    "memberof": "src/Res.js~Res",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Res.js~Res#isSent",
    "access": "public",
    "description": "Whether the response has been sent to the client.",
    "lineNumber": 168,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if the response has been sent."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if the response has been sent."
    },
    "params": []
  },
  {
    "__docId__": 156,
    "kind": "file",
    "name": "src/_typeDefs.js",
    "content": "/* eslint-disable import/unambiguous, max-len */\n\n/**\n * A plain object that is shared for the given request. It is passed to all policies that execute for the given\n * store method, which can read and mutate it freely, and passed into the given store method. The meta object can be\n * used to add non-serializable data that is useful in the store method, data that is tangentially related to the\n * request but does not belong in the body (such as information about the current user session), cached results of\n * policies that may be repeated in an expression, etc.\n * @typedef {object} Meta\n * @example\n * async function getCurrentUserPolicy(req, res, meta) {\n *   if (meta.user) {\n *     // We already have fetched the user (i.e. this policy has probably already been run in this request).\n *     return\n *   }\n *   const authHeader = req.getHeader('Authorization')\n *   if (!authHeader) {\n *     throw new AutonymError(AutonymError.UNAUTHORIZED, 'You must be logged in to perform this action.')\n *   }\n *\n *   const [, token] = authHeader.split('Bearer ')\n *   const data = await verify(token)\n *   // Save data on meta object, which will be accessible on subsequent policies and store methods.\n *   meta.user = await User.findOne(data.userId)\n * }\n *\n * function canCreatePostPolicy(req, res, meta) {\n *   // Access the user object saved in the previous policy. Note: this means this policy is tightly coupled to the\n *   // getCurrentUserPolicy and will throw an error if it is used in isolation, which would by default return a 500\n *   // error. We *could* `await getCurrentUserPolicy(req, res, meta)` here if we wanted to use this policy alone.\n *   if (!meta.user.privileges.includes('createPost')) {\n *     throw new AutonymError(AutonymError.FORBIDDEN, 'You must have the createPost privilege to perform this action.')\n *   }\n * }\n *\n * const Post = new Model({\n *   name: 'post',\n *   policies: {\n *     create: { and: [getCurrentUserPolicy, canCreatePostPolicy] },\n *   },\n *   store: {\n *     // Since the `getCurrentUserPolicy` was called before inserting, the `user` object is available in the store\n *     // methods. If calling the API programmatically, e.g. `Post.create()`, this data will need to be supplied\n *     // manually in the `create` method, since policies are not called when using the model instance directly.\n *     create: (data, meta) => Db.insert({ ...data, authorId: meta.user.id }),\n *   }\n * })\n */\n\n/**\n * An object mapping store method names to policy hooks. The hooks will be run for the given method. If the value is\n * just `true`, it is assumed that all requests will be honored and no policies are necessary for any lifecycle event;\n * if just `false`, it is assumed no requests will be honored.\n * @typedef {object} ModelPolicies\n * @property {object|boolean} [create] Policies to run for the `create` method.\n * @property {Operand} [create.preSchema] An expression to evaluate before the data is validated against the schema.\n * @property {Operand} [create.postSchema] An expression to evaluate after the data is validated against the schema.\n * @property {Operand} [create.preStore] An expression to evaluate before the data is passed to the store method.\n * @property {Operand} [create.postStore] An expression to evaluate after the store method has completed.\n * @property {object|boolean} [find] Policies to run for the `find` method.\n * @property {Operand} [find.preStore] An expression to evaluate before the data is passed to the store method.\n * @property {Operand} [find.postStore] An expression to evaluate after the store method has completed.\n * @property {object|boolean} [findOne] Policies to run for the `findOne` method.\n * @property {Operand} [findOne.preStore] An expression to evaluate before the data is passed to the store method.\n * @property {Operand} [findOne.postStore] An expression to evaluate after the store method has completed.\n * @property {object|boolean} [findOneAndUpdate] Policies to run for the `findOneAndUpdate` method.\n * @property {Operand} [findOneAndUpdate.preSchema] An expression to evaluate before the data is validated against the\n * schema.\n * @property {Operand} [findOneAndUpdate.postSchema] An expression to evaluate after the data is validated against the\n * schema.\n * @property {Operand} [findOneAndUpdate.preStore] An expression to evaluate before the data is passed to the store\n * method.\n * @property {Operand} [findOneAndUpdate.postStore] An expression to evaluate after the store method has completed.\n * @property {object|boolean} [findOneAndDelete] Policies to run for the `findOneAndDelete` method.\n * @property {Operand} [findOneAndDelete.preStore] An expression to evaluate before the data is passed to the store\n * method.\n * @property {Operand} [findOneAndDelete.postStore] An expression to evaluate after the store method has completed.\n * @example\n * const Post = new Model({\n *   name: 'post',\n *   policies: {\n *     create: {\n *       // Users must be logged in and have the proper permission to create a post\n *       preSchema: { and: [getCurrentUserPolicy, canCreatePostPolicy] },\n *       // Once the post is validated, it is safe to read and manipulate the request data\n *       postSchema: trimPostBodyPolicy,\n *     },\n *     find: {\n *       // All requests to get all posts should include a header with the total count\n *       postStore: addTotalCountHeaderToResponsePolicy,\n *     },\n *     findOneAndUpdate: {\n *       // Users must be logged in and own the post that they are trying to update\n *       preSchema: { and: [getCurrentUserPolicy, userIsOwnerOfPostPolicy] },\n *       postSchema: trimPostBodyPolicy,\n *     },\n *     findOneAndDelete: {\n *       preStore: { and: [getCurrentUserPolicy, userIsOwnerOfPostPolicy] },\n *     },\n *   },\n *   store: {},\n * })\n */\n\n/**\n * An operand is a boolean (to explicitly allow or deny) or a policy function, or an AndExpression, OrExpression, or\n * NotExpression, which can be used to assemble more complex policies out of a series of policy functions.\n * AndExpressions, OrExpressions, and NotExpressions may be nested recursively. For details, see the documentation\n * of [async-boolean-expression-evaluator](https://github.com/mmiller42/async-boolean-expression-evaluator).\n * @typedef {boolean|Policy|AndExpression|OrExpression|NotExpression} Operand\n */\n\n/**\n * An object with the key `and` set to an array of Operands. The expression will only evaluate to true if none of\n * the operands are false or throw errors. The error of the first policy to throw will be used, and short-circuiting\n * will prevent further policies from executing when one throws.\n * @typedef {object} AndExpression\n * @property {Operand[]} and\n */\n\n/**\n * An object with the key `or` set to an array of Operands. The expression will only evaluate to true if at least\n * one of the operands is true or does not throw an error. The error of the last policy that throws will be used,\n * and short-circuiting will prevent further policies from executing when one does not throw.\n * @typedef {object} OrExpression\n * @property {Operand[]} or\n */\n\n/**\n * An object with the key `not` set to an Operand. The expression will only evaluate to true if the result of the\n * operand is false or throws an error (which will be swallowed). If the result is true or does not throw an error,\n * a generic error will be thrown, so implement a custom policy if you require a more specific error message.\n * @typedef {object} NotExpression\n * @property {Operand} not\n */\n\n/**\n * A function that is evaluated before a store method. It may modify the request data, validate the data and throw an\n * error, or determine that the client may not perform this request and throw an error. Policies may be combined in\n * an expression and applied to various store methods in a model's configuration.\n * @typedef {function(req: AutonymReq, res: AutonymRes, meta: Meta): Promise.<*, Error>|*} Policy\n * @example\n * async function getCurrentUserPolicy(req, res, meta) {\n *   if (meta.user) {\n *     // We already have fetched the user (i.e. this policy has probably already been run in this request).\n *     return\n *   }\n *   const authHeader = req.getHeader('Authorization')\n *   if (!authHeader) {\n *     throw new AutonymError(AutonymError.UNAUTHORIZED, 'You must be logged in to perform this action.')\n *   }\n *\n *   const [, token] = authHeader.split('Bearer ')\n *   const data = await verify(token)\n *   // Save data on meta object, which will be accessible on subsequent policies and store methods.\n *   meta.user = await User.findOne(data.userId)\n * }\n * @example\n * function canCreatePostPolicy(req, res, meta) {\n *   // Access the user object saved in the previous policy. Note: this means this policy is tightly coupled to the\n *   // getCurrentUserPolicy and will throw an error if it is used in isolation, which would by default return a 500\n *   // error. We *could* `await getCurrentUserPolicy(req, res, meta)` here if we wanted to use this policy alone.\n *   if (!meta.user.privileges.includes('createPost')) {\n *     throw new AutonymError(AutonymError.FORBIDDEN, 'You must have the createPost privilege to perform this action.')\n *   }\n * }\n * @example\n * function userIsOwnerOfPostPolicy(req, res, meta) {\n *   if (req.getId() !== req.meta.user.id) {\n *     throw new AutonymError(AutonymError.FORBIDDEN, 'You are not the owner of this post.')\n *   }\n * }\n * @example\n * function trimPostBodyPolicy(req, res, meta) {\n *   // If this policy is in the postSchema hook, it is safe to get and set data.\n *   req.setData({ body: req.getData().body.trim() })\n * }\n * @example\n * Post.count = () => Db.selectCount('posts')\n *\n * async function addTotalCountHeaderToResponsePolicy(req, res, meta) {\n *   // If this policy is in the postStore hook, it is safe to get and modify the response data.\n *\n *   const model = req.getModel()\n *   if (model.count) {\n *     const totalCount = await req.getModel().count()\n *     res.setHeader('X-Total-Count', totalCount)\n *   }\n * }\n */\n\n/**\n * An object that has methods for CRUD operations for a typical record. It does not matter if this is a plain\n * object or an instance of a Store class, as long as it has these members on it.\n * @typedef {object} Store\n * @property {function(data: SerializedRecord, meta: Meta, unserializedData: Record):\n * Promise.<SerializedRecord, Error>|SerializedRecord} [create] A function called to create a new record.\n * @property {function(query: object, meta: Meta): Promise.<SerializedRecord[], Error>|SerializedRecord[]} [find]\n * A function called to find records.\n * @property {function(id: string, meta: Meta): Promise.<SerializedRecord, Error>|SerializedRecord} [findOne] A\n * function called to find a single record.\n * @property {function(id: string, data: SerializedRecord, completeData: SerializedRecord, meta: Meta, unserializedData: Record, unserializedCompleteData: Record):\n * Promise.<SerializedRecord, Error>|SerializedRecord} [findOneAndUpdate] A function called to update a single record.\n * @property {function(id: string, meta: Meta): Promise.<*, Error>|*} [findOneAndDelete] A function called to delete\n * a single record.\n * @param {function(data: Record): Promise.<SerializedRecord, Error>|SerializedRecord} [serialize] A function\n * called to reformat the request body automatically before passing it into the `create` and `findOneAndUpdate`\n * store methods. It must be able to handle partial data objects.\n * @param {function(data: SerializedRecord): Promise.<Record, Error>|Record} [unserialize] A function called to\n * reformat the store method's return value automatically before passing it into `postStore` policies and\n * subsequently to the response.\n * @example\n * const Post = new Model({\n *   name: 'post',\n *   store: {\n *     create: data => Db.insert('posts', data),\n *     find: () => Db.selectAll('posts'),\n *     findOne: id => Db.selectOne('posts', { id }),\n *     findOneAndUpdate: (id, data) => Db.updateWhere('posts', { id }, data),\n *     findOneAndDelete: id => Db.deleteWhere('posts', { id }),\n *\n *     // Column names are the same as properties on the data, but in snake-case\n *     serialize: data => mapKeys(data, property => snakeCase(property)),\n *     // Properties are the same as column names in the table, but in camel-case\n *     unserialize: data => mapKeys(data, columnName => camelCase(columnName)),\n *   },\n * })\n */\n\n/**\n * An object that represents a record that may be operated on by a model. A record may be partial (e.g. if it is\n * the properties to update in a findOneAndUpdate request). If it is the result of a store method, it should at\n * least have an `id` property.\n * @typedef {object} Record\n */\n\n/**\n * A Record that has been transformed by the serialize function as a matter of convenience. It is only used in the\n * store methods and is always unserialized back into a Record before being passed onto other code outside the\n * store methods.\n * @typedef {object} SerializedRecord\n */\n\n/**\n * A JSON schema object. [Read more about JSON Schema](http://json-schema.org/)\n * @typedef {object} Schema\n */\n\n/**\n * Options to pass to the JSON schema validator. [See options](https://github.com/epoberezkin/ajv#options)\n * @typedef {object} AjvOptions\n */\n",
    "static": true,
    "longname": "/home/circleci/autonym/src/_typeDefs.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 157,
    "kind": "typedef",
    "name": "Meta",
    "memberof": "src/_typeDefs.js",
    "static": true,
    "longname": "src/_typeDefs.js~Meta",
    "access": "public",
    "description": "A plain object that is shared for the given request. It is passed to all policies that execute for the given\nstore method, which can read and mutate it freely, and passed into the given store method. The meta object can be\nused to add non-serializable data that is useful in the store method, data that is tangentially related to the\nrequest but does not belong in the body (such as information about the current user session), cached results of\npolicies that may be repeated in an expression, etc.",
    "examples": [
      "async function getCurrentUserPolicy(req, res, meta) {\n  if (meta.user) {\n    // We already have fetched the user (i.e. this policy has probably already been run in this request).\n    return\n  }\n  const authHeader = req.getHeader('Authorization')\n  if (!authHeader) {\n    throw new AutonymError(AutonymError.UNAUTHORIZED, 'You must be logged in to perform this action.')\n  }\n\n  const [, token] = authHeader.split('Bearer ')\n  const data = await verify(token)\n  // Save data on meta object, which will be accessible on subsequent policies and store methods.\n  meta.user = await User.findOne(data.userId)\n}\n\nfunction canCreatePostPolicy(req, res, meta) {\n  // Access the user object saved in the previous policy. Note: this means this policy is tightly coupled to the\n  // getCurrentUserPolicy and will throw an error if it is used in isolation, which would by default return a 500\n  // error. We *could* `await getCurrentUserPolicy(req, res, meta)` here if we wanted to use this policy alone.\n  if (!meta.user.privileges.includes('createPost')) {\n    throw new AutonymError(AutonymError.FORBIDDEN, 'You must have the createPost privilege to perform this action.')\n  }\n}\n\nconst Post = new Model({\n  name: 'post',\n  policies: {\n    create: { and: [getCurrentUserPolicy, canCreatePostPolicy] },\n  },\n  store: {\n    // Since the `getCurrentUserPolicy` was called before inserting, the `user` object is available in the store\n    // methods. If calling the API programmatically, e.g. `Post.create()`, this data will need to be supplied\n    // manually in the `create` method, since policies are not called when using the model instance directly.\n    create: (data, meta) => Db.insert({ ...data, authorId: meta.user.id }),\n  }\n})"
    ],
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "Meta"
    }
  },
  {
    "__docId__": 158,
    "kind": "typedef",
    "name": "ModelPolicies",
    "memberof": "src/_typeDefs.js",
    "static": true,
    "longname": "src/_typeDefs.js~ModelPolicies",
    "access": "public",
    "description": "An object mapping store method names to policy hooks. The hooks will be run for the given method. If the value is\njust `true`, it is assumed that all requests will be honored and no policies are necessary for any lifecycle event;\nif just `false`, it is assumed no requests will be honored.",
    "examples": [
      "const Post = new Model({\n  name: 'post',\n  policies: {\n    create: {\n      // Users must be logged in and have the proper permission to create a post\n      preSchema: { and: [getCurrentUserPolicy, canCreatePostPolicy] },\n      // Once the post is validated, it is safe to read and manipulate the request data\n      postSchema: trimPostBodyPolicy,\n    },\n    find: {\n      // All requests to get all posts should include a header with the total count\n      postStore: addTotalCountHeaderToResponsePolicy,\n    },\n    findOneAndUpdate: {\n      // Users must be logged in and own the post that they are trying to update\n      preSchema: { and: [getCurrentUserPolicy, userIsOwnerOfPostPolicy] },\n      postSchema: trimPostBodyPolicy,\n    },\n    findOneAndDelete: {\n      preStore: { and: [getCurrentUserPolicy, userIsOwnerOfPostPolicy] },\n    },\n  },\n  store: {},\n})"
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "object",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "create",
        "description": "Policies to run for the `create` method."
      },
      {
        "nullable": null,
        "types": [
          "Operand"
        ],
        "spread": false,
        "optional": true,
        "name": "create.preSchema",
        "description": "An expression to evaluate before the data is validated against the schema."
      },
      {
        "nullable": null,
        "types": [
          "Operand"
        ],
        "spread": false,
        "optional": true,
        "name": "create.postSchema",
        "description": "An expression to evaluate after the data is validated against the schema."
      },
      {
        "nullable": null,
        "types": [
          "Operand"
        ],
        "spread": false,
        "optional": true,
        "name": "create.preStore",
        "description": "An expression to evaluate before the data is passed to the store method."
      },
      {
        "nullable": null,
        "types": [
          "Operand"
        ],
        "spread": false,
        "optional": true,
        "name": "create.postStore",
        "description": "An expression to evaluate after the store method has completed."
      },
      {
        "nullable": null,
        "types": [
          "object",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "find",
        "description": "Policies to run for the `find` method."
      },
      {
        "nullable": null,
        "types": [
          "Operand"
        ],
        "spread": false,
        "optional": true,
        "name": "find.preStore",
        "description": "An expression to evaluate before the data is passed to the store method."
      },
      {
        "nullable": null,
        "types": [
          "Operand"
        ],
        "spread": false,
        "optional": true,
        "name": "find.postStore",
        "description": "An expression to evaluate after the store method has completed."
      },
      {
        "nullable": null,
        "types": [
          "object",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "findOne",
        "description": "Policies to run for the `findOne` method."
      },
      {
        "nullable": null,
        "types": [
          "Operand"
        ],
        "spread": false,
        "optional": true,
        "name": "findOne.preStore",
        "description": "An expression to evaluate before the data is passed to the store method."
      },
      {
        "nullable": null,
        "types": [
          "Operand"
        ],
        "spread": false,
        "optional": true,
        "name": "findOne.postStore",
        "description": "An expression to evaluate after the store method has completed."
      },
      {
        "nullable": null,
        "types": [
          "object",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "findOneAndUpdate",
        "description": "Policies to run for the `findOneAndUpdate` method."
      },
      {
        "nullable": null,
        "types": [
          "Operand"
        ],
        "spread": false,
        "optional": true,
        "name": "findOneAndUpdate.preSchema",
        "description": "An expression to evaluate before the data is validated against the\nschema."
      },
      {
        "nullable": null,
        "types": [
          "Operand"
        ],
        "spread": false,
        "optional": true,
        "name": "findOneAndUpdate.postSchema",
        "description": "An expression to evaluate after the data is validated against the\nschema."
      },
      {
        "nullable": null,
        "types": [
          "Operand"
        ],
        "spread": false,
        "optional": true,
        "name": "findOneAndUpdate.preStore",
        "description": "An expression to evaluate before the data is passed to the store\nmethod."
      },
      {
        "nullable": null,
        "types": [
          "Operand"
        ],
        "spread": false,
        "optional": true,
        "name": "findOneAndUpdate.postStore",
        "description": "An expression to evaluate after the store method has completed."
      },
      {
        "nullable": null,
        "types": [
          "object",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "findOneAndDelete",
        "description": "Policies to run for the `findOneAndDelete` method."
      },
      {
        "nullable": null,
        "types": [
          "Operand"
        ],
        "spread": false,
        "optional": true,
        "name": "findOneAndDelete.preStore",
        "description": "An expression to evaluate before the data is passed to the store\nmethod."
      },
      {
        "nullable": null,
        "types": [
          "Operand"
        ],
        "spread": false,
        "optional": true,
        "name": "findOneAndDelete.postStore",
        "description": "An expression to evaluate after the store method has completed."
      }
    ],
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "ModelPolicies"
    }
  },
  {
    "__docId__": 159,
    "kind": "typedef",
    "name": "Operand",
    "memberof": "src/_typeDefs.js",
    "static": true,
    "longname": "src/_typeDefs.js~Operand",
    "access": "public",
    "description": "An operand is a boolean (to explicitly allow or deny) or a policy function, or an AndExpression, OrExpression, or\nNotExpression, which can be used to assemble more complex policies out of a series of policy functions.\nAndExpressions, OrExpressions, and NotExpressions may be nested recursively. For details, see the documentation\nof [async-boolean-expression-evaluator](https://github.com/mmiller42/async-boolean-expression-evaluator).",
    "type": {
      "types": [
        "boolean",
        "Policy",
        "AndExpression",
        "OrExpression",
        "NotExpression"
      ],
      "optional": false,
      "name": "Operand"
    }
  },
  {
    "__docId__": 160,
    "kind": "typedef",
    "name": "AndExpression",
    "memberof": "src/_typeDefs.js",
    "static": true,
    "longname": "src/_typeDefs.js~AndExpression",
    "access": "public",
    "description": "An object with the key `and` set to an array of Operands. The expression will only evaluate to true if none of\nthe operands are false or throw errors. The error of the first policy to throw will be used, and short-circuiting\nwill prevent further policies from executing when one throws.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Operand[]"
        ],
        "spread": false,
        "optional": false,
        "name": "and",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "AndExpression"
    }
  },
  {
    "__docId__": 161,
    "kind": "typedef",
    "name": "OrExpression",
    "memberof": "src/_typeDefs.js",
    "static": true,
    "longname": "src/_typeDefs.js~OrExpression",
    "access": "public",
    "description": "An object with the key `or` set to an array of Operands. The expression will only evaluate to true if at least\none of the operands is true or does not throw an error. The error of the last policy that throws will be used,\nand short-circuiting will prevent further policies from executing when one does not throw.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Operand[]"
        ],
        "spread": false,
        "optional": false,
        "name": "or",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "OrExpression"
    }
  },
  {
    "__docId__": 162,
    "kind": "typedef",
    "name": "NotExpression",
    "memberof": "src/_typeDefs.js",
    "static": true,
    "longname": "src/_typeDefs.js~NotExpression",
    "access": "public",
    "description": "An object with the key `not` set to an Operand. The expression will only evaluate to true if the result of the\noperand is false or throws an error (which will be swallowed). If the result is true or does not throw an error,\na generic error will be thrown, so implement a custom policy if you require a more specific error message.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Operand"
        ],
        "spread": false,
        "optional": false,
        "name": "not",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "NotExpression"
    }
  },
  {
    "__docId__": 163,
    "kind": "typedef",
    "name": "Policy",
    "memberof": "src/_typeDefs.js",
    "static": true,
    "longname": "src/_typeDefs.js~Policy",
    "access": "public",
    "description": "A function that is evaluated before a store method. It may modify the request data, validate the data and throw an\nerror, or determine that the client may not perform this request and throw an error. Policies may be combined in\nan expression and applied to various store methods in a model's configuration.",
    "examples": [
      "async function getCurrentUserPolicy(req, res, meta) {\n  if (meta.user) {\n    // We already have fetched the user (i.e. this policy has probably already been run in this request).\n    return\n  }\n  const authHeader = req.getHeader('Authorization')\n  if (!authHeader) {\n    throw new AutonymError(AutonymError.UNAUTHORIZED, 'You must be logged in to perform this action.')\n  }\n\n  const [, token] = authHeader.split('Bearer ')\n  const data = await verify(token)\n  // Save data on meta object, which will be accessible on subsequent policies and store methods.\n  meta.user = await User.findOne(data.userId)\n}",
      "function canCreatePostPolicy(req, res, meta) {\n  // Access the user object saved in the previous policy. Note: this means this policy is tightly coupled to the\n  // getCurrentUserPolicy and will throw an error if it is used in isolation, which would by default return a 500\n  // error. We *could* `await getCurrentUserPolicy(req, res, meta)` here if we wanted to use this policy alone.\n  if (!meta.user.privileges.includes('createPost')) {\n    throw new AutonymError(AutonymError.FORBIDDEN, 'You must have the createPost privilege to perform this action.')\n  }\n}",
      "function userIsOwnerOfPostPolicy(req, res, meta) {\n  if (req.getId() !== req.meta.user.id) {\n    throw new AutonymError(AutonymError.FORBIDDEN, 'You are not the owner of this post.')\n  }\n}",
      "function trimPostBodyPolicy(req, res, meta) {\n  // If this policy is in the postSchema hook, it is safe to get and set data.\n  req.setData({ body: req.getData().body.trim() })\n}",
      "Post.count = () => Db.selectCount('posts')\n\nasync function addTotalCountHeaderToResponsePolicy(req, res, meta) {\n  // If this policy is in the postStore hook, it is safe to get and modify the response data.\n\n  const model = req.getModel()\n  if (model.count) {\n    const totalCount = await req.getModel().count()\n    res.setHeader('X-Total-Count', totalCount)\n  }\n}"
    ],
    "type": {
      "types": [
        "function(req: AutonymReq, res: AutonymRes, meta: Meta): Promise.<*, Error>",
        "*"
      ],
      "optional": false,
      "name": "Policy"
    }
  },
  {
    "__docId__": 164,
    "kind": "typedef",
    "name": "Store",
    "memberof": "src/_typeDefs.js",
    "static": true,
    "longname": "src/_typeDefs.js~Store",
    "access": "public",
    "description": "An object that has methods for CRUD operations for a typical record. It does not matter if this is a plain\nobject or an instance of a Store class, as long as it has these members on it.",
    "examples": [
      "const Post = new Model({\n  name: 'post',\n  store: {\n    create: data => Db.insert('posts', data),\n    find: () => Db.selectAll('posts'),\n    findOne: id => Db.selectOne('posts', { id }),\n    findOneAndUpdate: (id, data) => Db.updateWhere('posts', { id }, data),\n    findOneAndDelete: id => Db.deleteWhere('posts', { id }),\n\n    // Column names are the same as properties on the data, but in snake-case\n    serialize: data => mapKeys(data, property => snakeCase(property)),\n    // Properties are the same as column names in the table, but in camel-case\n    unserialize: data => mapKeys(data, columnName => camelCase(columnName)),\n  },\n})"
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function(data: Record): Promise.<SerializedRecord, Error>",
          "SerializedRecord"
        ],
        "spread": false,
        "optional": true,
        "name": "serialize",
        "description": "A function\ncalled to reformat the request body automatically before passing it into the `create` and `findOneAndUpdate`\nstore methods. It must be able to handle partial data objects."
      },
      {
        "nullable": null,
        "types": [
          "function(data: SerializedRecord): Promise.<Record, Error>",
          "Record"
        ],
        "spread": false,
        "optional": true,
        "name": "unserialize",
        "description": "A function called to\nreformat the store method's return value automatically before passing it into `postStore` policies and\nsubsequently to the response."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "function(data: SerializedRecord, meta: Meta, unserializedData: Record):\nPromise.<SerializedRecord, Error>",
          "SerializedRecord"
        ],
        "spread": false,
        "optional": true,
        "name": "create",
        "description": "A function called to create a new record."
      },
      {
        "nullable": null,
        "types": [
          "function(query: object, meta: Meta): Promise.<SerializedRecord[], Error>",
          "SerializedRecord[]"
        ],
        "spread": false,
        "optional": true,
        "name": "find",
        "description": "A function called to find records."
      },
      {
        "nullable": null,
        "types": [
          "function(id: string, meta: Meta): Promise.<SerializedRecord, Error>",
          "SerializedRecord"
        ],
        "spread": false,
        "optional": true,
        "name": "findOne",
        "description": "A\nfunction called to find a single record."
      },
      {
        "nullable": null,
        "types": [
          "function(id: string, data: SerializedRecord, completeData: SerializedRecord, meta: Meta, unserializedData: Record, unserializedCompleteData: Record):\nPromise.<SerializedRecord, Error>",
          "SerializedRecord"
        ],
        "spread": false,
        "optional": true,
        "name": "findOneAndUpdate",
        "description": "A function called to update a single record."
      },
      {
        "nullable": null,
        "types": [
          "function(id: string, meta: Meta): Promise.<*, Error>",
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "findOneAndDelete",
        "description": "A function called to delete\na single record."
      }
    ],
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "Store"
    }
  },
  {
    "__docId__": 165,
    "kind": "typedef",
    "name": "Record",
    "memberof": "src/_typeDefs.js",
    "static": true,
    "longname": "src/_typeDefs.js~Record",
    "access": "public",
    "description": "An object that represents a record that may be operated on by a model. A record may be partial (e.g. if it is\nthe properties to update in a findOneAndUpdate request). If it is the result of a store method, it should at\nleast have an `id` property.",
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "Record"
    }
  },
  {
    "__docId__": 166,
    "kind": "typedef",
    "name": "SerializedRecord",
    "memberof": "src/_typeDefs.js",
    "static": true,
    "longname": "src/_typeDefs.js~SerializedRecord",
    "access": "public",
    "description": "A Record that has been transformed by the serialize function as a matter of convenience. It is only used in the\nstore methods and is always unserialized back into a Record before being passed onto other code outside the\nstore methods.",
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "SerializedRecord"
    }
  },
  {
    "__docId__": 167,
    "kind": "typedef",
    "name": "Schema",
    "memberof": "src/_typeDefs.js",
    "static": true,
    "longname": "src/_typeDefs.js~Schema",
    "access": "public",
    "description": "A JSON schema object. [Read more about JSON Schema](http://json-schema.org/)",
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "Schema"
    }
  },
  {
    "__docId__": 168,
    "kind": "typedef",
    "name": "AjvOptions",
    "memberof": "src/_typeDefs.js",
    "static": true,
    "longname": "src/_typeDefs.js~AjvOptions",
    "access": "public",
    "description": "Options to pass to the JSON schema validator. [See options](https://github.com/epoberezkin/ajv#options)",
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "AjvOptions"
    }
  },
  {
    "__docId__": 169,
    "kind": "file",
    "name": "src/createInMemoryStore.js",
    "content": "import AutonymError from './AutonymError'\n\n/**\n * Creates a store that reads and writes data in memory.\n * @returns {Store} A complete set of store methods.\n * @example\n * const Person = new Model({\n *   name: 'person',\n *   schema: {\n *     type: 'object',\n *     properties: {\n *       firstName: { type: 'string' },\n *       lastName: { type: 'string' },\n *     },\n *     required: ['firstName', 'lastName'],\n *   },\n *   store: createInMemoryStore(),\n * })\n *\n * const data = await Person.create({ firstName: 'Matt', lastName: 'Miller' })\n * console.log(data) // { id: '1', firstName: 'Matt', lastName: 'Miller' }\n *\n * const data = await Person.find()\n * console.log(data) // [{ id: '1', firstName: 'Matt', lastName: 'Miller' }]\n *\n * const data = await Person.findOne('1')\n * console.log(data) // { id: '1', firstName: 'Matt', lastName: 'Miller' }\n *\n * const data = await Person.findOneAndUpdate('1', { firstName: 'Matthew' })\n * console.log(data) // { id: '1', firstName: 'Matthew', lastName: 'Miller' }\n *\n * const data = await Person.findOneAndDelete('1')\n * console.log(data) // { id: '1' }\n *\n * try {\n *   await Person.findOne('1')\n * } catch (err) {\n *   console.log(err) // '[NOT_FOUND] Record not found.'\n * }\n */\nconst createInMemoryStore = () => {\n  const records = []\n  let counter = 0\n  const findRecordIndex = id => {\n    const index = records.findIndex(record => record.id === id)\n    if (index < 0) {\n      throw new AutonymError(AutonymError.NOT_FOUND, 'Record not found')\n    }\n    return index\n  }\n\n  return {\n    create: data => records[records.push({ ...data, id: String(++counter) }) - 1],\n    find: () => records,\n    findOne: id => records[findRecordIndex(id)],\n    findOneAndUpdate: (id, data) => Object.assign(records[findRecordIndex(id)], data),\n    findOneAndDelete: id => records.splice(findRecordIndex(id), 1)[0],\n  }\n}\n\nexport default createInMemoryStore\n",
    "static": true,
    "longname": "/home/circleci/autonym/src/createInMemoryStore.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 170,
    "kind": "function",
    "name": "createInMemoryStore",
    "memberof": "src/createInMemoryStore.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/createInMemoryStore.js~createInMemoryStore",
    "access": "public",
    "export": true,
    "importPath": "autonym/lib/createInMemoryStore",
    "importStyle": "createInMemoryStore",
    "description": "Creates a store that reads and writes data in memory.",
    "examples": [
      "const Person = new Model({\n  name: 'person',\n  schema: {\n    type: 'object',\n    properties: {\n      firstName: { type: 'string' },\n      lastName: { type: 'string' },\n    },\n    required: ['firstName', 'lastName'],\n  },\n  store: createInMemoryStore(),\n})\n\nconst data = await Person.create({ firstName: 'Matt', lastName: 'Miller' })\nconsole.log(data) // { id: '1', firstName: 'Matt', lastName: 'Miller' }\n\nconst data = await Person.find()\nconsole.log(data) // [{ id: '1', firstName: 'Matt', lastName: 'Miller' }]\n\nconst data = await Person.findOne('1')\nconsole.log(data) // { id: '1', firstName: 'Matt', lastName: 'Miller' }\n\nconst data = await Person.findOneAndUpdate('1', { firstName: 'Matthew' })\nconsole.log(data) // { id: '1', firstName: 'Matthew', lastName: 'Miller' }\n\nconst data = await Person.findOneAndDelete('1')\nconsole.log(data) // { id: '1' }\n\ntry {\n  await Person.findOne('1')\n} catch (err) {\n  console.log(err) // '[NOT_FOUND] Record not found.'\n}"
    ],
    "lineNumber": 41,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Store} A complete set of store methods."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Store"
      ],
      "spread": false,
      "description": "A complete set of store methods."
    },
    "params": []
  },
  {
    "__docId__": 171,
    "kind": "file",
    "name": "src/createModelMiddleware.js",
    "content": "import { createErrorMiddleware, createStoreMiddleware } from './middleware'\nimport { isPlainObject, values } from 'lodash'\nimport Model from './Model'\nimport { checkForUnrecognizedProperties } from './utils'\nimport { Router as createRouter } from 'express'\n\n/**\n * Creates an Express middleware router that binds routes for all of the given models.\n * @param {object} config Configuration.\n * @param {Model[]|object.<string, Model>} config.models A collection of model instances. This may be an object or\n * an array, but if it is an object, the keys will be ignored.\n * @returns {Promise.<Router, Error>} A promise that resolves with an Express router. The router has an additional\n * property `modelInitializations` which is an array of promises, in case you want to capture errors from the init\n * functions.\n * @example\n * app.use(createModelMiddleware({\n *   models: [Post, User],\n * }))\n * @example\n * const modelMiddleware = createModelMiddleware({\n *   models: [Post, User],\n * })\n * app.use(modelMiddleware)\n *\n * Promise.all(modelMiddleware.modelInitializations).catch(err => {\n *   console.error(err)\n *   process.exit(1)\n * })\n */\nexport default function createModelMiddleware(config) {\n  const normalizedConfig = normalizeConfig(config)\n\n  const router = createRouter()\n  router.modelInitializations = normalizedConfig.models.map(model => model.init())\n\n  normalizedConfig.models.forEach(model => {\n    router.use(`/${model.getRoute()}`, createStoreMiddleware(model))\n  })\n  router.use(createErrorMiddleware())\n\n  return router\n}\n\nfunction normalizeConfig(config) {\n  if (!isPlainObject(config)) {\n    throw new TypeError('config parameter must be a plain object.')\n  }\n  if (!Array.isArray(config.models) && !isPlainObject(config.models)) {\n    throw new TypeError('config.models parameter must be an array.')\n  }\n\n  checkForUnrecognizedProperties('config', config, ['models'])\n\n  const normalizedConfig = { ...config }\n  if (!Array.isArray(normalizedConfig.models)) {\n    normalizedConfig.models = values(normalizedConfig.models)\n  }\n\n  normalizedConfig.models.forEach((model, i) => {\n    if (!(model instanceof Model)) {\n      throw new TypeError(\n        `config.models parameter must be an array of Model instances, but the model at index ${i} is not. Did you forget to wrap your model definition in the autonym.model decorator?`\n      )\n    }\n  })\n\n  return normalizedConfig\n}\n",
    "static": true,
    "longname": "/home/circleci/autonym/src/createModelMiddleware.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 172,
    "kind": "function",
    "name": "createModelMiddleware",
    "memberof": "src/createModelMiddleware.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/createModelMiddleware.js~createModelMiddleware",
    "access": "public",
    "export": true,
    "importPath": "autonym/lib/createModelMiddleware",
    "importStyle": "createModelMiddleware",
    "description": "Creates an Express middleware router that binds routes for all of the given models.",
    "examples": [
      "app.use(createModelMiddleware({\n  models: [Post, User],\n}))",
      "const modelMiddleware = createModelMiddleware({\n  models: [Post, User],\n})\napp.use(modelMiddleware)\n\nPromise.all(modelMiddleware.modelInitializations).catch(err => {\n  console.error(err)\n  process.exit(1)\n})"
    ],
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Router, Error>} A promise that resolves with an Express router. The router has an additional\nproperty `modelInitializations` which is an array of promises, in case you want to capture errors from the init\nfunctions."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": "Configuration."
      },
      {
        "nullable": null,
        "types": [
          "Model[]",
          "object.<string, Model>"
        ],
        "spread": false,
        "optional": false,
        "name": "config.models",
        "description": "A collection of model instances. This may be an object or\nan array, but if it is an object, the keys will be ignored."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Router, Error>"
      ],
      "spread": false,
      "description": "A promise that resolves with an Express router. The router has an additional\nproperty `modelInitializations` which is an array of promises, in case you want to capture errors from the init\nfunctions."
    }
  },
  {
    "__docId__": 173,
    "kind": "function",
    "name": "normalizeConfig",
    "memberof": "src/createModelMiddleware.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/createModelMiddleware.js~normalizeConfig",
    "access": "public",
    "export": false,
    "importPath": "autonym/lib/createModelMiddleware",
    "importStyle": null,
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 174,
    "kind": "file",
    "name": "src/createResponderMiddleware.js",
    "content": "/**\n * Creates an Express middleware that responds to the request with either the requested data or the error. It only\n * handles requests that have passed through `createModelMiddleware`, and will forward other requests to the next\n * middleware\n * @returns {function[]} The Express middleware.\n * @example\n * app.use(createResponderMiddleware())\n */\nexport default function createResponderMiddleware() {\n  return [\n    (req, res, next) => sendResponse(null, req, res, next),\n    (error, req, res, next) => sendResponse(error, req, res, next),\n  ]\n\n  function sendResponse(error, req, res, next) {\n    if (!res.autonym) {\n      next(error)\n      return\n    }\n\n    res.status(res.autonym.getStatus())\n    const data = res.autonym.getData()\n    if (data === null) {\n      res.end()\n    } else {\n      res.json(data)\n    }\n\n    next(error)\n  }\n}\n",
    "static": true,
    "longname": "/home/circleci/autonym/src/createResponderMiddleware.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 175,
    "kind": "function",
    "name": "createResponderMiddleware",
    "memberof": "src/createResponderMiddleware.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/createResponderMiddleware.js~createResponderMiddleware",
    "access": "public",
    "export": true,
    "importPath": "autonym/lib/createResponderMiddleware",
    "importStyle": "createResponderMiddleware",
    "description": "Creates an Express middleware that responds to the request with either the requested data or the error. It only\nhandles requests that have passed through `createModelMiddleware`, and will forward other requests to the next\nmiddleware",
    "examples": [
      "app.use(createResponderMiddleware())"
    ],
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{function[]} The Express middleware."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function[]"
      ],
      "spread": false,
      "description": "The Express middleware."
    },
    "params": []
  },
  {
    "__docId__": 176,
    "kind": "file",
    "name": "src/index.js",
    "content": "import AutonymError from './AutonymError'\nimport Model from './Model'\nimport Req from './Req'\nimport Res from './Res'\nimport createInMemoryStore from './createInMemoryStore'\nimport createModelMiddleware from './createModelMiddleware'\nimport createResponderMiddleware from './createResponderMiddleware'\n\nexport { AutonymError, Model, Req, Res, createInMemoryStore, createModelMiddleware, createResponderMiddleware }\n",
    "static": true,
    "longname": "/home/circleci/autonym/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 177,
    "kind": "file",
    "name": "src/middleware/createErrorMiddleware.js",
    "content": "import AutonymError from '../AutonymError'\n\nexport default function createErrorMiddleware() {\n  return (error, req, res, next) => {\n    if (!res.autonym) {\n      next(error)\n      return\n    }\n\n    const autonymError = AutonymError.fromError(error)\n    res.autonym._isPopulated = true\n    res.autonym.setStatus(autonymError.getStatus())\n    res.autonym.setData(autonymError.getPayload())\n\n    next(autonymError)\n  }\n}\n",
    "static": true,
    "longname": "/home/circleci/autonym/src/middleware/createErrorMiddleware.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 178,
    "kind": "function",
    "name": "createErrorMiddleware",
    "memberof": "src/middleware/createErrorMiddleware.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/middleware/createErrorMiddleware.js~createErrorMiddleware",
    "access": "public",
    "export": true,
    "importPath": "autonym/lib/middleware/createErrorMiddleware",
    "importStyle": "createErrorMiddleware",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 179,
    "kind": "file",
    "name": "src/middleware/createStoreMiddleware.js",
    "content": "import { cloneDeep, mapValues } from 'lodash'\nimport AsyncBooleanExpressionEvaluator from 'async-boolean-expression-evaluator'\nimport AutonymError from '../AutonymError'\nimport Req from '../Req'\nimport Res from '../Res'\nimport { Router as createRouter } from 'express'\n\nexport default function createStoreMiddleware(model) {\n  const modelWithHooks = model.withHooks(createPolicyHooks())\n\n  const router = createRouter({ mergeParams: true })\n\n  router.route('/').post((req, res, next) => callStoreMethod(create, req, res, next))\n  router.route('/').get((req, res, next) => callStoreMethod(find, req, res, next))\n  router.route('/:id').get((req, res, next) => callStoreMethod(findOne, req, res, next))\n  router.route('/:id').patch((req, res, next) => callStoreMethod(findOneAndUpdate, req, res, next))\n  router.route('/:id').put((req, res, next) => callStoreMethod(findOneAndUpdate, req, res, next))\n  router.route('/:id').delete((req, res, next) => callStoreMethod(findOneAndDelete, req, res, next))\n\n  return router\n\n  function createPolicyHooks() {\n    return mapValues(model.getPolicies(), hooks =>\n      mapValues(hooks, (expression, hook) => async (req, res, meta, data) => {\n        if (data && (hook === 'postSchema' || hook === 'preStore')) {\n          req.setData(data, true)\n        }\n\n        if (hook === 'postSchema') {\n          req._isValidated = true\n        }\n\n        if (hook === 'postStore') {\n          res._isPopulated = true\n          res.setData(data, true)\n        }\n\n        await evaluatePolicies(expression, req, res, meta)\n\n        if (data && hook === 'preSchema') {\n          return req.getCompleteData()\n        } else if (data && (hook === 'postSchema' || hook === 'preStore')) {\n          return req.getData()\n        } else if (data && hook === 'postStore') {\n          return res.getData()\n        } else {\n          return null\n        }\n      })\n    )\n  }\n\n  async function evaluatePolicies(expression, req, res, meta) {\n    let lastError = null\n    const evaluator = new AsyncBooleanExpressionEvaluator(async operand => {\n      if (typeof operand === 'function') {\n        try {\n          await operand(req, res, meta)\n          return true\n        } catch (err) {\n          // `err` may be undefined if this is the result of a `not` expression\n          lastError = err\n          return false\n        }\n      } else if (typeof operand === 'boolean') {\n        if (operand) {\n          return true\n        } else {\n          // If operand is just false, use generic error\n          lastError = new AutonymError(AutonymError.FORBIDDEN, 'This action may not be performed.')\n          return false\n        }\n      } else {\n        throw new TypeError(\n          `Policy operands for model \"${model.getName()}\" are invalid. Operands may be functions or booleans, received ${typeof operand}.`\n        )\n      }\n    })\n\n    const result = await evaluator.execute(expression)\n    if (!result) {\n      throw lastError || new AutonymError(AutonymError.FORBIDDEN, 'This action may not be performed.')\n    }\n  }\n\n  async function callStoreMethod(method, req, res, next) {\n    const meta = cloneDeep(model.getInitialMeta())\n    const autonymReq = new Req(req, model, meta)\n    const autonymRes = new Res(res, model, meta)\n\n    let autonymError = null\n    try {\n      const { status } = await method(autonymReq, autonymRes, meta)\n      if (autonymRes.getStatus() === null) {\n        autonymRes.setStatus(status)\n      }\n    } catch (err) {\n      autonymError = AutonymError.fromError(err).toClientError()\n    }\n\n    next(autonymError)\n  }\n\n  async function create(req, res, meta) {\n    await modelWithHooks.create(req.getData(), meta, [req, res, meta])\n    return { status: Res.CREATED }\n  }\n\n  async function find(req, res, meta) {\n    await modelWithHooks.find(req.getQuery(), meta, [req, res, meta])\n    return { status: Res.OK }\n  }\n\n  async function findOne(req, res, meta) {\n    await modelWithHooks.findOne(req.getId(), meta, [req, res, meta])\n    return { status: Res.OK }\n  }\n\n  async function findOneAndUpdate(req, res, meta) {\n    const completeData = await req.getCompleteData()\n    await modelWithHooks.findOneAndUpdate(req.getId(), req.getData(), completeData, meta, [req, res, meta])\n    return { status: Res.OK }\n  }\n\n  async function findOneAndDelete(req, res, meta) {\n    await modelWithHooks.findOneAndDelete(req.getId(), meta, [req, res, meta])\n    return { status: Res.OK }\n  }\n}\n",
    "static": true,
    "longname": "/home/circleci/autonym/src/middleware/createStoreMiddleware.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 180,
    "kind": "function",
    "name": "createStoreMiddleware",
    "memberof": "src/middleware/createStoreMiddleware.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/middleware/createStoreMiddleware.js~createStoreMiddleware",
    "access": "public",
    "export": true,
    "importPath": "autonym/lib/middleware/createStoreMiddleware",
    "importStyle": "createStoreMiddleware",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 181,
    "kind": "file",
    "name": "src/middleware/index.js",
    "content": "import createErrorMiddleware from './createErrorMiddleware'\nimport createStoreMiddleware from './createStoreMiddleware'\n\nexport { createErrorMiddleware, createStoreMiddleware }\n",
    "static": true,
    "longname": "/home/circleci/autonym/src/middleware/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 182,
    "kind": "file",
    "name": "src/utils/index.js",
    "content": "import { difference, forEach, isPlainObject, reduce } from 'lodash'\n\nexport function checkForUnrecognizedProperties(parameterName, object, expectedProperties) {\n  if (!object) {\n    return\n  }\n\n  const invalidKeys = difference(Object.keys(object), expectedProperties)\n  if (invalidKeys.length !== 0) {\n    throw new TypeError(`Unexpected properties on ${parameterName} parameter: \"${invalidKeys.join('\", \"')}\".`)\n  }\n}\n\nexport function cloneInstance(instance, newProps) {\n  return Object.assign(Object.create(Object.getPrototypeOf(instance)), instance, newProps)\n}\n\nexport function deleteUndefineds(object) {\n  forEach(object, (value, key) => {\n    if (typeof value === 'object' && value !== null) {\n      deleteUndefineds(value)\n    } else if (value === undefined) {\n      delete object[key]\n    }\n  })\n}\n\nexport function filterToProperties(fullObject, partialObject) {\n  return reduce(\n    fullObject,\n    (result, value, key) => {\n      if (key in partialObject) {\n        const partialValue = partialObject[key]\n        if (isPlainObject(value) && isPlainObject(partialValue)) {\n          result[key] = filterToProperties(value, partialValue)\n        } else if (Array.isArray(value) && Array.isArray(partialValue)) {\n          result[key] = partialValue.map((partialValueItem, i) => filterToProperties(value[i], partialValueItem))\n        } else {\n          result[key] = partialValue\n        }\n      }\n      return result\n    },\n    {}\n  )\n}\n",
    "static": true,
    "longname": "/home/circleci/autonym/src/utils/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 183,
    "kind": "function",
    "name": "checkForUnrecognizedProperties",
    "memberof": "src/utils/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/index.js~checkForUnrecognizedProperties",
    "access": "public",
    "export": true,
    "importPath": "autonym/lib/utils/index",
    "importStyle": "{checkForUnrecognizedProperties}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "parameterName",
        "types": [
          "*"
        ]
      },
      {
        "name": "object",
        "types": [
          "*"
        ]
      },
      {
        "name": "expectedProperties",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 184,
    "kind": "function",
    "name": "cloneInstance",
    "memberof": "src/utils/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/index.js~cloneInstance",
    "access": "public",
    "export": true,
    "importPath": "autonym/lib/utils/index",
    "importStyle": "{cloneInstance}",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [
      {
        "name": "instance",
        "types": [
          "*"
        ]
      },
      {
        "name": "newProps",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 185,
    "kind": "function",
    "name": "deleteUndefineds",
    "memberof": "src/utils/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/index.js~deleteUndefineds",
    "access": "public",
    "export": true,
    "importPath": "autonym/lib/utils/index",
    "importStyle": "{deleteUndefineds}",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "object",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 186,
    "kind": "function",
    "name": "filterToProperties",
    "memberof": "src/utils/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/index.js~filterToProperties",
    "access": "public",
    "export": true,
    "importPath": "autonym/lib/utils/index",
    "importStyle": "{filterToProperties}",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "params": [
      {
        "name": "fullObject",
        "types": [
          "*"
        ]
      },
      {
        "name": "partialObject",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "kind": "index",
    "content": "# autonym\n\n[![CircleCI](https://circleci.com/gh/mmiller42/autonym/tree/master.svg?style=svg)](https://circleci.com/gh/mmiller42/autonym/tree/master) [![Greenkeeper badge](https://badges.greenkeeper.io/mmiller42/autonym.svg)](https://greenkeeper.io/)\n\nA KISS JSON REST API framework that can be mounted to your Express application.\n\nThe API, guides, and examples are available on [our website](https://autonym.io/), which is generated using [ESDoc](https://esdoc.org/).\n\n## Installation\n\n```bash\nnpm install autonym\n```\n\n## Quick Start\n\nSee the [basic example project](https://github.com/mmiller42/autonym-examples/tree/master/basic).\n\n## Philosophy\n\nAutonym is another framework built on top of <a href=\"https://expressjs.com/\">Express</a> to simplify building REST APIs for your records. However, its philosophy sets it apart from most other Node.js API frameworks.\n\nIt is extremely lightweight and written in ES6. By design, it eliminates the need to scaffold controllers in your API, because they can be inferred automatically from your models. Models are driven by simple configuration objects and in many cases can just forward their arguments to an ORM. As a result, APIs built in Autonym require little coding but still offer total control over each CRUD action for a record, and are very easy to understand at a glance.\n\n* **It's just middleware.** Most frameworks take over your entire application, making it difficult to adjust an existing app to the new framework's setup. This also results in endless frustration when trying to do something the framework isn't designed to do. Autonym is just mounted like any other middleware, so you can add other middleware and handlers before or after Autonym to do whatever you want, the way you normally would.\n\n* **No bloat.** Autonym follows the single responsibility principle and seeks to do just one thing well: map requests to CRUD actions. Following from the previous principle, if your server needs to serve static assets as well, just mount middleware beside Autonym for your other routes. If you authenticate with JWTs, simply mount your JWT middleware before Autonym.\n\n* **Your API, your response.** Autonym makes a habit of never sending the response to the user directly. This allows you to intercept the response to make any adjustments. If you want to let Autonym handle the response, it exposes another middleware to mount after that will send the response.\n\n* **Data validation is standardized.** Autonym validates JSON documents using the JSON schema spec. JSON schemas are an industry standard and, being JSON documents themselves, are completely portable and ingestable by other clients, even written in other languages. For more comprehensive validation beyond JSON schemas, Autonym allows you to define validation and sanitization policies and map them to CRUD actions.\n\n* **For better or for worse, database schemas are not document schemas.** In real life, there is rarely a perfect 1:1 relationship between properties on the request body and column names in a table. Autonym doesn't attempt to unify data models -- in fact, it doesn't care about databases at all! However, data store implementations are free to define mapping functions to translate documents to queries.\n\n* **It has no opinion about ORMs.** Many REST frameworks are tightly coupled to ORMs, but, like the previous point, we recognized that sometimes in the real world you fight ORMs more than you love them, because one size never fits all. Autonym lets you integrate them to whatever extent you want. Autonym just expects a model to implement five CRUD methods. Whether those methods forward the data to an ORM or just run some queries or ops directly is up to you. Some models might directly correspond to a Mongo collection or SQL table, while other models might be virtual representations of more complex data. That distinction is completely up to you.\n\n* **A clear distinction between a programmatic API and REST API, but without controllers.** Autonym splits the work of validating into two distinct phases: schemas and policies. You define them together, but policies, which only are applicable to your REST API, are not run when you just want to import your model and insert a record. This means you don't have to split up your resource definition into a separate model and controller, but you can still access your model directly without mocking a request.\n\n* **Configuration is driven by plain objects.** This means that every piece that makes up a model -- the methods for persisting data to your database, the combinations of policies used to transform and validate requests, and the schemas that define your record properties -- are all trivial to define, reuse, abstract, and assemble.\n\n* **Isolation for testability.** Each component of an Autonym app is designed to be unit testable: JSON schemas can be tested independently, policies are just simple JavaScript functions that can be imported directly, and models are simple, isolated objects that never deal with request or response objects.\n\n* **Error handling is a snap.** Autonym ships with its own error class that allows you to throw errors like you normally would, without being conscious of when they are runtime errors or simply bad requests. Errors thrown when using the programmatic API are passed on to error-handling middleware, while errors that occur during an HTTP request are intelligently (but still explicitly) handled and returned to the client.\n\n* **Embrace ES6+.** Autonym app components are heavily class-based and Autonym and its sister projects are written with Babel. No more callback hell!\n\nIt's worth noting that the developers behind Autonym envisioned a simplistic data model, and as a result there are some definite drawbacks and limitations to the built-in behaviors of the framework.\n\n* Autonym has no intrinsic understanding of related records. The API does not understand foreign references and will only return record ids. This means that establishing relationships between models must be handled at the database layer or manually in the API layer. However, this eliminates some of the complexity with setting up and consuming an API with intricate routing, unintentionally costly joins, and recursive embedding.\n\n* Autonym requires all records to have a primary key that is named id. Composite primary keys or primary keys named something different are not currently supported. This is to make REST calls trivial by using standard record identifiers in the URL.\n\n## Guide\n\n### Glossary\n\nThese are high-level concepts and vocabulary for working with an Autonym application.\n\n* **Model**: A model is an instance of the `Model` class provided by Autonym. Constructed with a configuration object, a model defines its schema, policies, store methods, and so on. A model instance has static methods on it that make it trivial to import elsewhere in the application to create, read, update, and delete records programmatically. It's also designed to plug into the Autonym middleware to be evaluated in a HTTP request.\n\n* **Schema**: A schema is part of a model's configuration. It is an object that follows the [JSON schema specification](http://json-schema.org/) for defining the properties of this type of record.\n\n* **Policy**: A policy is a function that is run when a request hits your API for a particular model action. Policies are like Express middleware, with the added advantage that they can be easily chained together in \"and\" and \"or\" statements. They can be used to validate the request, add computed properties, and manipulate the response before it is returned to the client. Since they are just functions, ideally they are defined in other parts of the application and imported into models for easy reuse between different models.\n\n* **Store methods**: Store methods are the five core methods that are configured on a model that perform your CRUD operations: `create`, `find`, `findOne`, `findOneAndUpdate`, and `findOneAndDelete`. These methods are exposed on the programmatic API for the model and are called by the middleware, provided the policies permit the request. Oftentimes, these methods can be shared among many models, i.e. with an ORM. Reusable implementations of store methods are commonly referred to as stores.\n\n* **`req` and `res`**: Policies are passed request and response objects, just like Express middleware; however, these are not the standard objects provided by Express. They are wrapped in the `AutonymReq` and `AutonymRes` classes, which are designed to place an emphasis on identifying the user's actions, retrieving data safely, working with the model's programmatic API, and safeguarding against common programming errors.\n\n* **Meta**: Policies and store methods are also passed a `meta` object. This is a plain JavaScript object that is shared for the entire duration of the request, and is passed from policy to policy, in addition to being passed to each of the store methods. This object can be used to cache supplemental information about the request, e.g. the current user session or search keywords from the query string; information that might be useful in the store method, such as filters to apply to a SQL query; or any other metadata pertaining to the request. Unlike the request data, which must be serializable in order to pass schema validation, the meta object may contain class instances.\n\n* **Model middleware**: A middleware that can be mounted on your Express app. Provided with your models, it will intercept requests to your model endpoints to perform the appropriate API actions.\n\n* **Responder middleware**: A middleware that can be mounted on your Express app, after the `autonym` middleware. In between the two middleware, you may install your own middleware to quash errors, add response headers, manipulate the payload, and so on. This middleware sends the response to the client.\n\n* **`AutonymError`**: A subclass of `Error`. Instances of `AutonymError` should be thrown whenever possible from policies and store methods. These errors have preset types that will determine the status code if they are thrown during an HTTP request; if not provided a code, it will be assumed that the error message should not be enclosed in the response.\n",
    "longname": "/home/circleci/autonym/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  }
]