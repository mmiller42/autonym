{
    "docs": [
        {
            "location": "/", 
            "text": "Autonym\n\n\nAutonym is another framework built on top of Express to simplify building REST APIs for your resources. However, its\nphilosophy sets it apart from most other Node.js API frameworks.\n\n\nIt is extremely lightweight and written in ES6. By design, it eliminates the need to scaffold controllers in your API,\nbecause they can be inferred automatically from your models. Models are just static classes with a few methods and in\nmany cases can just forward their arguments to an ORM. As a result, APIs built in Autonym require little coding but\nstill offer total control over each CRUD action for a resource, and are very easy to understand at a glance.\n\n\nPhilosophy\n\n\n\n\n\n\nIt's just middleware.\n Most frameworks take over your entire application, making it difficult to adjust an\n  existing app to the new framework's setup. This also results in endless frustration when trying to do something the\n  framework isn't designed to do. Autonym is just mounted like any other middleware, so you can add other middleware\n  and handlers before or after Autonym to do whatever you want, the way you normally would.\n\n\n\n\n\n\nNo bloat.\n Autonym follows the single responsibility principle and seeks to do just one thing well: map requests\n  to CRUD actions. Following from the previous principle, if your server needs to serve static assets as well, just\n  mount middleware beside Autonym for your other routes. If you authenticate with JWTs, mount your JWT middleware\n  before Autonym.\n\n\n\n\n\n\nYour API, your response.\n Autonym makes a habit of never sending the response to the user directly. This allows\n  you to intercept the response to make any adjustments. If you want to let Autonym handle the response, it exposes\n  another middleware to mount after that will send the response.\n\n\n\n\n\n\nData validation is standardized.\n Autonym validates JSON documents using the JSON schema spec. Since JSON\n  schemas are JSON documents themselves, they can be exposed to API clients who can do pre-emptive validation on their\n  end. For more comprehensive validation beyond JSON schemas, Autonym allows you to define validation and sanitization\n  \npolicies\n and map them to CRUD actions.\n\n\n\n\n\n\nFor better or for worse, database schemas are not document schemas.\n In real life, there is rarely a perfect 1:1\n  relationship between properties on the request body and column names in a table. Autonym doesn't attempt to unify\n  data models -- in fact, it doesn't care about databases at all! However, data store implementations are free to\n  define mapping functions to translate documents to queries.\n\n\n\n\n\n\nIt has no opinion about ORMs.\n Many REST frameworks are tightly coupled to ORMs, but, like the previous point,\n  we recognized that sometimes in the real world you fight ORMs more than you love them. Autonym lets you integrate\n  them to whatever extent you want. Autonym just expects a model to implement five CRUD methods. Whether those methods\n  forward the data to an ORM or just run some queries or ops directly is up to you.\n\n\n\n\n\n\nIsolation for testability.\n Each component of an Autonym app is designed to be unit testable: JSON schemas can\n  be tested independently, policies are just simple JavaScript functions that can be imported directly, models are\n  simple, isolated classes that never deal with request or response objects.\n\n\n\n\n\n\nEmbrace ES6.\n Autonym app components are heavily class-based and Autonym and its sister projects are written\n  with Babel. You can always write components with ES5, but Autonym is designed for modern apps. As a downside, it\n  \ndoes\n require higher versions of Node.\n\n\n\n\n\n\nDrawbacks\n\n\nIt is important to point out some of the limitations of Autonym as well.\n\n\n\n\n\n\nAutonym has no intrinsic understanding of related resources. The API does not understand foreign references and\n  will only return resource ids. This means that establishing relationships between models must be handled at the\n  database layer or manually in the API layer. However, this eliminates some of the complexity with setting up and\n  consuming an API with intricate routing, unintentionally costly joins, and recursive embedding.\n\n\n\n\n\n\nAutonym requires all resources to have a primary key that is named \nid\n. Composite primary keys or primary keys named\n  something different are not currently supported.\n\n\n\n\n\n\nAPIs generated by Autonym return data in a basic format but as of yet don't adhere to any strict standards. On the\n  roadmap is potentially an extension for conforming to \nJSON:API\n.", 
            "title": "Intro"
        }, 
        {
            "location": "/#autonym", 
            "text": "Autonym is another framework built on top of Express to simplify building REST APIs for your resources. However, its\nphilosophy sets it apart from most other Node.js API frameworks.  It is extremely lightweight and written in ES6. By design, it eliminates the need to scaffold controllers in your API,\nbecause they can be inferred automatically from your models. Models are just static classes with a few methods and in\nmany cases can just forward their arguments to an ORM. As a result, APIs built in Autonym require little coding but\nstill offer total control over each CRUD action for a resource, and are very easy to understand at a glance.", 
            "title": "Autonym"
        }, 
        {
            "location": "/#philosophy", 
            "text": "It's just middleware.  Most frameworks take over your entire application, making it difficult to adjust an\n  existing app to the new framework's setup. This also results in endless frustration when trying to do something the\n  framework isn't designed to do. Autonym is just mounted like any other middleware, so you can add other middleware\n  and handlers before or after Autonym to do whatever you want, the way you normally would.    No bloat.  Autonym follows the single responsibility principle and seeks to do just one thing well: map requests\n  to CRUD actions. Following from the previous principle, if your server needs to serve static assets as well, just\n  mount middleware beside Autonym for your other routes. If you authenticate with JWTs, mount your JWT middleware\n  before Autonym.    Your API, your response.  Autonym makes a habit of never sending the response to the user directly. This allows\n  you to intercept the response to make any adjustments. If you want to let Autonym handle the response, it exposes\n  another middleware to mount after that will send the response.    Data validation is standardized.  Autonym validates JSON documents using the JSON schema spec. Since JSON\n  schemas are JSON documents themselves, they can be exposed to API clients who can do pre-emptive validation on their\n  end. For more comprehensive validation beyond JSON schemas, Autonym allows you to define validation and sanitization\n   policies  and map them to CRUD actions.    For better or for worse, database schemas are not document schemas.  In real life, there is rarely a perfect 1:1\n  relationship between properties on the request body and column names in a table. Autonym doesn't attempt to unify\n  data models -- in fact, it doesn't care about databases at all! However, data store implementations are free to\n  define mapping functions to translate documents to queries.    It has no opinion about ORMs.  Many REST frameworks are tightly coupled to ORMs, but, like the previous point,\n  we recognized that sometimes in the real world you fight ORMs more than you love them. Autonym lets you integrate\n  them to whatever extent you want. Autonym just expects a model to implement five CRUD methods. Whether those methods\n  forward the data to an ORM or just run some queries or ops directly is up to you.    Isolation for testability.  Each component of an Autonym app is designed to be unit testable: JSON schemas can\n  be tested independently, policies are just simple JavaScript functions that can be imported directly, models are\n  simple, isolated classes that never deal with request or response objects.    Embrace ES6.  Autonym app components are heavily class-based and Autonym and its sister projects are written\n  with Babel. You can always write components with ES5, but Autonym is designed for modern apps. As a downside, it\n   does  require higher versions of Node.", 
            "title": "Philosophy"
        }, 
        {
            "location": "/#drawbacks", 
            "text": "It is important to point out some of the limitations of Autonym as well.    Autonym has no intrinsic understanding of related resources. The API does not understand foreign references and\n  will only return resource ids. This means that establishing relationships between models must be handled at the\n  database layer or manually in the API layer. However, this eliminates some of the complexity with setting up and\n  consuming an API with intricate routing, unintentionally costly joins, and recursive embedding.    Autonym requires all resources to have a primary key that is named  id . Composite primary keys or primary keys named\n  something different are not currently supported.    APIs generated by Autonym return data in a basic format but as of yet don't adhere to any strict standards. On the\n  roadmap is potentially an extension for conforming to  JSON:API .", 
            "title": "Drawbacks"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting Started\n\n\nThe quickest way to get started is by using the \nYeoman generator\n,\nwhich scaffolds the structure of an Autonym app for you. However, this guide will take you through building an API from\nscratch, so we can walk through line by line how it works.\n\n\nPrerequisites\n\n\nIn these examples, we'll touch on each feature of Autonym by building an API for managing Person objects that are stored\nin a Postgres database. Needless to say, you'll want to have a recent version of Node/NPM installed as well as Postgres.\n\n\nIn addition, all examples of Autonym use features of ES6 that will require running with \nBabel\n.\nThis tutorial does include what is needed to get a Babel application running, but we don't cover ES6 features here. We\nrecommend checking out \nthe ES6 features list by lukehoban\n as a guide for any unfamiliar\nsyntax. You should also be comfortable with Express and understand concepts like middleware, request/response handling,\nand callbacks. Last, Autonym uses JSON schems. A complete example is included in this walkthrough, but you'll want to\nget comfortable writing your own schemas when you build a production API. We recommend the\n\nthorough documentation\n provided by the Space Telescope\nScience Institute.\n\n\nInstallation\n\n\nLet's start with a totally blank application. Create a new directory, change into it, and \nnpm init\n and follow the\nwizard to create a new \npackage.json\n in your project.\n\n\nNext, we'll install some dependencies to transpile the Babel source into ES5 at runtime. We'll also install\n\nnodemon\n, which is just a convenient tool that watches your source code for changes and\nautomatically restarts the API server.\n\n\nmkdir new-api \n cd $_\nnpm init\nnpm install --save-dev babel-cli babel-preset-node5 babel-preset-stage-2 nodemon\n\n\n\n\nTo run this app, you can use the \nnodemon\n executable instead of just \nnode\n. However, we want to override the command\nthat nodemon executes when the watched files change -- instead of running the \nnode\n executable, it needs to run\n\nbabel-node\n to transpile our ES6.\n\n\nLet's open up \npackage.json\n. Under the \nscripts\n section, we can add a \nstart\n script that will serve as an aliased\nshortcut to our command.\n\n\nscripts\n: {\n  \nstart\n: \nnodemon ./lib/app.js --exec babel-node\n\n}\n\n\n\n\nThe last thing we need to do is create a file called \n.babelrc\n in our project directory and populate it with:\n\n\n{\n  \npresets\n: [\nnode5\n, \nstage-2\n]\n}\n\n\n\n\nThis is enough to get a Babel app running; now let's install our normal dependencies. Autonym is just Express\nmiddleware, so we will need to install Express and its JSON-parsing companion body-parser. We'll install Autonym and the\nPostgres extension to make building models that connect to Postgres easier. Finally, we'll need some utility packages\nfor error handling; we'll cover what the last two dependencies are used for later in this guide.\n\n\nnpm install --save express body-parser autonym autonym-postgres-store autonym-client-errors instance-of-name\n\n\n\n\nCoding\n\n\nLet's organize our app by placing source code in a \nlib\n directory, and we'll create the entry point to our app as\n\napp.js\n like we specified in the \nnpm start\n script.\n\n\nA simple Express app\n\n\nIn \nlib/app.js\n we'll start by just creating a typical Express server.\n\n\n// lib/app.js\n\nimport express from 'express';\nimport bodyParser from 'body-parser';\nimport http from 'http';\n\nconst app = express();\napp.use(bodyParser.json({}));\n\napp.get('/', (req, res) =\n res.json({message: 'Hello world!'}));\n\nhttp.createServer(app).listen(3000, err =\n {\n  if (err) { throw err; }\n  console.log('Listening on port 3000');\n});\n\n\n\n\nThis is a bare-bones Express application. If you run this app with \nnpm start\n and everything goes well, you'll see a\n\nListening on port 3000\n in your stdout. Visiting \nhttp://localhost:3000/\n in your browser or favorite REST client\n(we're fans of \nPostman\n) should yield the JSON \n{\"message\":\"Hello world!\"}\n.\n\n\nRefactoring our Express app\n\n\nLet's make a few improvements before we continue: we'll replace the literal \n3000\n with an environment variable so it\ncan be controlled by the service running our app. We'll replace \nthrow err;\n with a reusable \nhandleError\n function for\nour application. And we'll register a listener for the \nunhandledRejection\n event, which will fire if any promises throw\nexceptions that aren't caught elsewhere in the application (just in case -- Node swallows up unhandled promise\nrejections, unlike synchronous exceptions, which will crash the application).\n\n\n// lib/app.js\n\nimport express from 'express';\nimport bodyParser from 'body-parser';\nimport http from 'http';\nimport handleError from './handle-error';\n\nprocess.on('unhandledRejection', handleError);\n\nconst app = express();\napp.use(bodyParser.json({}));\n\napp.get('/', (req, res) =\n res.json({message: 'Hello world!'}));\n\nhttp.createServer(app).listen(process.env.PORT, err =\n {\n  if (err) { return handleError(err); }\n  console.log(`Listening on port ${process.env.PORT}`);\n});\n\n\n\n\nNow, of course, \nPORT\n is an environment variable, so we should export it or save it to our shell profile.\n\n\nexport PORT=3000\n\n\n\n\nAnd we'll need to create our error handler as well, so create a new \nhandle-error.js\n.\n\n\nThis will just be a small file exporting a reusable function. This function will be called when errors occur and can\nchoose to log them out, send alerts to your on-call team, or crash the application.\n\n\nFor now, we're just going to throw the error, which will crash the app.\n\n\n// lib/handle-error.js\n\nfunction handleError (err) {\n  setImmediate(() =\n { throw err; });\n}\n\nexport default handleError;\n\n\n\n\nNote that we wrapped it in a \nsetImmediate\n call. This is because Express' default error when an exception is thrown\nduring a request is to catch it and pass it to a generic \"error middleware\", which simply logs the exception and carries\non. If an error makes it this far, we'd like to crash the app to reset its state. If we wrap the code in a\n\nsetImmediate\n call, it can't be caught by Express, since it will be thrown after Express finishes with the request.\n\n\nIntegrating Autonym\n\n\nAlright, let's actually start integrating Autonym into our Express application.\n\n\nBecause Autonym is just Express middleware, we can simply add an \napp.use()\n call with a new instance of Autonym.\n\n\n// lib/app.js\n\nimport express from 'express';\nimport bodyParser from 'body-parser';\nimport http from 'http';\nimport Autonym, {AutonymResponder} from 'autonym';\nimport handleError from './handle-error';\n\nprocess.on('unhandledRejection', handleError);\n\nconst app = express();\napp.use(bodyParser.json({}));\n\napp.get('/', (req, res) =\n res.json({message: 'Hello world!'}));\n\napp.use(new Autonym(__dirname).middleware);\napp.use(new AutonymResponder(handleError).middleware);\n\nhttp.createServer(app).listen(process.env.PORT, err =\n {\n  if (err) { return handleError(err); }\n  console.log(`Listening on port ${process.env.PORT}`);\n});\n\n\n\n\nA few things are going on here:\n\n\n\n\n\n\nWe created a new instance of the \nAutonym\n class, passing \n__dirname\n into the constructor. \n__dirname\n is a Node.js\n  constant that refers to the absolute path to the currently executing file (i.e. the path to \n./lib\n). Autonym will\n  attempt to import various \"components\" from this given directory by searching for files that match a pattern. Autonym\n  will read these components by a special set of rules, and you can find details about how it all works on the\n  \nAutonym page\n.\n\n\n\n\n\n\nWe mounted the \nautonym.middleware\n middleware onto the app. Now, all requests will pass through the instance of\n  Autonym at this stage in the middleware stack. Of course, since we mounted it after our \napp.get()\n middleware (which\n  does not call \nnext\n), our hello world example will not pass through Autonym. The best way to adapt existing\n  applications with Autonym is to add the Autonym middleware near the bottom of the stack, so as to not affect existing\n  APIs.\n\n\n\n\n\n\nWe also mounted \nnew AutonymResponder(handleError).middleware\n. The \nautonym.middleware\n will validate and process the\n  request, but the \nautonymResponder.middleware\n middleware will actually send it to the client. These are deliberately\n  kept separate so that you can tweak the response however you like in between these two handlers. Note that the\n  \nAutonymResponder\n constructor takes a \nhandleError\n function. In addition to passing the error to the client, this\n  function can be used to capture and handle errors that happened during the request/response life cycle. More about the\n  AutonymResponder can be found on \nits dedicated page\n.\n\n\n\n\n\n\nAutonym is now going to look for files in the directory we passed into the constructor, in this case the absolute path\nto \n./lib\n. Autonym will check for three subdirectories in the path provided to it: \nmodels\n, \npolicies\n, and \nschemas\n.\nGo ahead and create these three directories in the \nlib\n folder. Next, we'll describe and build each of these\ncomponents.\n\n\nOur first model\n\n\nLet's create a model that represents a person. Models are just classes that extend from the \nModel\n abstract class that\nis exported by Autonym.\n\n\n// lib/models/person.model.js\n\nimport {Model} from 'autonym';\n\nclass Person extends Model {\n}\n\nexport default Person;\n\n\n\n\nThis model doesn't do much yet! But, if we create some static methods with specific names, we can start to add\nfunctionality to our model. Let's start with the \n_find()\n method, which should return a list of people.\n\n\n// lib/models/person.model.js\n\nimport {Model} from 'autonym';\n\nclass Person extends Model {\n  static _find (query) {\n    return Promise.resolve([\n      {\n        id: '1',\n        firstName: 'John',\n        lastName: 'Galt',\n        employerId: '42'\n      }\n    ]);\n  }\n}\n\nexport default Person;\n\n\n\n\nBy defining this function, we've now added the ability for our API to \"get people.\" The abstract Model class noticed\nthat the \n_find()\n function was defined, so it will call it any time you make a GET request to \n/people\n. Your function\n\nmust\n return a promise and that promise \nmust\n pass back an array. For now, that array is just static data.\n\n\nThere are four other CRUD methods (\n_create()\n, \n_findOne()\n, \n_findOneAndUpdate()\n, \n_findOneAndDelete()\n) which are\ndescribed in more detail in the \nModel API\n. Note that if any of them aren't set on your\nmodel, it's okay -- your user will just receive a method not allowed error. However, note that \n_findOne()\n \nmust\n be\nset up in order for \n_findOneAndUpdate()\n and \n_findOneAndDelete()\n to work.\n\n\nGo ahead! Hit \nhttp://localhost:3000/people\n in your browser or Postman and you should get back the array.\n\n\nBehind the scenes, Autonym processes a GET request, parses the incoming data, forwards the relevant parts of the request\nto \n_find()\n, then reformats the results and passes them onto the next middleware in the stack. In this case, the next\nmiddleware is the AutonymResponder, which just returns the response. However, if you wanted to, for example, wrap that\narray inside an object (e.g. \n{\"data\": []}\n) or add some specific headers, you could add more middleware in between --\nall Autonym does is add some properties to the \nreq\n and \nres\n objects from Express with additional information. More\ninformation about how this works and how to hook into this process is available in the API section.\n\n\nUsing the Postgres Store\n\n\nWe could define the additional methods like \n_create()\n and \n_findOne()\n, but that might seem tedious. If we had a\ncustom datastore, we might implement these methods manually. But since we're using Postgres, we can automate that work.\n\n\nFirst, let's create a Postgres database and add a new table to hold people. Let's create a Postgres database and a new\ntable.\n\n\ncreatedb autonym_app\npsql autonym_app\n\n CREATE TABLE people (\n  id BIGSERIAL PRIMARY KEY,\n  first_name VARCHAR(255) NOT NULL,\n  last_name VARCHAR(255) NOT NULL,\n  employer_id BIGINT NOT NULL\n);\n\n\n\n\nNote that the primary key has to be a column called \nid\n for Autonym to work.\n\n\nWe also need to tell Autonym how to connect to our Postgres store. This is done with another environment variable, so\nyou let's export another environment variable.\n\n\nexport POSTGRES_CONNECTION=\npostgres://$USER@localhost:5432/autonym_app\n\n\n\n\n\nNow we can leverage the Postgres store extension in our model.\n\n\n// lib/models/person.model.js\n\nimport {Model} from 'autonym';\nimport PostgresStoreFactory from 'autonym-postgres-store';\n\nconst PostgresStore = PostgresStoreFactory();\n\nclass Person extends Model {\n  static _init () {\n    this.store = new PostgresStore('people');\n    super._implementDefaultStoreCrudMethods(this.store);\n  }\n}\n\nexport default Person;\n\n\n\n\nHere, we've attached a static \n_init()\n method. It creates a new property on the class called \nstore\n and instantiates a\n\nPostgresStore\n, passing in the name of our table. Then, we call \n_implementDefaultStoreCrudMethods()\n, which is a\nfunction on the abstract Model class, providing our store instance. All this fancy function does is copy the \ncreate()\n,\n\nfind()\n, \nfindOne()\n, \nfindOneAndUpdate()\n, \nfindOneAndDelete()\n, \nserialize()\n, and \nunserialize()\n functions from the\nstore to our model class. This is basically just a quicker way of doing something like:\n\n\nstatic _create () { return this.store.create(...arguments); }\nstatic _find () { return this.store.find(...arguments); }\nstatic _findOne () { return this.store.findOne(...arguments); }\n// ...\n\n\n\n\nAt this point, we've essentially defined our Person model, and it's fully integrated with Postgres. Using a REST client,\ntry some requests:\n\n\n\n\nPOST http://localhost:3000/people\n\n\n\n\nRequest\n\n\n{\nfirstName\n:\nJohn\n,\nlastName\n:\nGalt\n,\nemployerId\n:\n42\n}\n\n\n\n\nResponse\n\n\n{\nid\n:1,\nfirstName\n:\nJohn\n,\nlastName\n:\nGalt\n,\nemployerId\n:\n42\n}\n\n\n\n\n\n\nPOST http://localhost:3000/people\n\n\n\n\nRequest\n\n\n{\nfirstName\n:\nDagny\n,\nlastName\n:\nTaggart\n,\nemployerId\n:\n42\n}\n\n\n\n\nResponse\n\n\n{\nid\n:2,\nfirstName\n:\nDagny\n,\nlastName\n:\nTaggart\n,\nemployerId\n:\n42\n}\n\n\n\n\n\n\nGET http://localhost:3000/people\n\n\n\n\nResponse\n\n\n[{\nid\n:1,\nfirstName\n:\nJohn\n,\nlastName\n:\nGalt\n,\nemployerId\n:\n42\n},{\nid\n:2,\nfirstName\n:\nDagny\n,\nlastName\n:\nTaggart\n,\nemployerId\n:\n42\n}]\n\n\n\n\n\n\nGET http://localhost:3000/people/1\n\n\n\n\nResponse\n\n\n{\nid\n:1,\nfirstName\n:\nJohn\n,\nlastName\n:\nGalt\n,\nemployerId\n:\n42\n}\n\n\n\n\n\n\nPATCH http://localhost:3000/people/2\n\n\n\n\nRequest\n\n\n{\nlastName\n:\nGalt\n}\n\n\n\n\nResponse\n\n\n{\nid\n:2,\nfirstName\n:\nDagny\n,\nlastName\n:\nGalt\n,\nemployerId\n:\n42\n}\n\n\n\n\n\n\nGET http://localhost:3000/people?search[firstName][~]=dag\n\n\n\n\nResponse\n\n\n[{\nid\n:2,\nfirstName\n:\nDagny\n,\nlastName\n:\nGalt\n,\nemployerId\n:\n42\n}]\n\n\n\n\n\n\nGET http://localhost:3000/people?sort=+firstName\n\n\n\n\nResponse\n\n\n[{\nid\n:2,\nfirstName\n:\nDagny\n,\nlastName\n:\nGalt\n,\nemployerId\n:\n42\n},{\nid\n:1,\nfirstName\n:\nJohn\n,\nlastName\n:\nGalt\n,\nemployerId\n:\n42\n}]\n\n\n\n\n\n\nDELETE http://localhost:3000/people/1\n\n\n\n\nResponse\n\n\nno content\n\n\nAdding a JSON schema\n\n\nSo there we have a working model! However, you should probably see in your stdout a warning about missing a schema.\nWithout JSON schema validation, this is a huge security violation. Any data can be sent to our API and the Postgres\nstore will try to insert it, even if the columns don't exist, are of the wrong type, or worse -- are columns users\nshouldn't be allowed to write to (like \nid\n)!\n\n\nLet's create a JSON schema for our Person model. Properties that aren't defined in the schema will be automatically\ndiscarded from the request, and the defined properties will be properly validated.\n\n\n// lib/schemas/person.schema.json\n\n{\n  \nid\n: \nPerson\n,\n  \ntype\n: \nobject\n,\n  \nproperties\n: {\n    \nfirstName\n: {\ntype\n: \nstring\n, \nminLength\n: 1, \nmaxLength\n: 20},\n    \nlastName\n: {\ntype\n: \nstring\n, \nminLength\n: 1, \nmaxLength\n: 20},\n    \nemployerId\n: {\ntype\n: \nstring\n, \nminLength\n: 1, \nmaxLength\n: 10}\n  },\n  \nrequired\n: [\nfirstName\n, \nlastName\n, \nemployerId\n]\n}\n\n\n\n\nNow, JSON schema validation will be properly enforced against any operations to the model. The schema is automatically\nmatched to the model because its \nid\n is \nPerson\n, which is the same as the name of our model.\n\n\nIf you try sending an invalid request, you'll notice your app crashes. That's because the \nhandleError\n method is\ncrashing it when \nany\n error occurs. Let's make some adjustments.\n\n\n// lib/handle-error.js\n\nimport instanceOf from 'instance-of-name';\n\nfunction handleError (err) {\n  if ('internalQuery' in err) {\n    console.error(err);\n  } else if (instanceOf(err, 'ClientError')) {\n    console.log(err.message);\n  } else {\n    setImmediate(() =\n { throw err; });\n  }\n}\n\nexport default handleError;\n\n\n\n\nHere we'll walk through some changes we made:\n\n\n\n\nWe're \"duck-typing\" the error to see if it has an \ninternalQuery\n property. If that property exists, it probably means\n  the error originated from the Postgres database driver. This could mean something bad, but generally an erroneous\n  query doesn't mean the app has to crash, it might be due to a misconfigured model or a search query that just wouldn't\n  work. Let's log it out to stderr, but we'll keep the app going.\n\n\nThe next condition checks if the error was derived from a class called \nClientError\n. \nClientError\n is a special class\n  that Autonym uses for any errors that are the result of a bad request on behalf of the client. The app is totally fine,\n  but the user got back an error message. Here, we're printing it out just for verbosity, but we could safely ignore\n  these errors. You can read more about client errors \non their respective page\n.\n\n\nOtherwise we'll continue with our default behavior and crash the app.\n\n\n\n\nCreating a policy\n\n\nThe last feature we'll explore in this guide is policies. Policies are a lot like Express middleware and are simply\nfunctions that perform sanitization and validation on requests that are beyond the capabilities of JSON schemas. Common\nfunctions of policies are:\n\n\n\n\nadd a timestamp to every resource\n\n\nadd hard-coded filters to searches to restrict result sets\n\n\nvalidate that the user has permission to perform the action\n\n\n\n\nWe're going to only allow people to make updates if they are editing themselves. Let's create a policy that checks some\nproperty on the request to see if it matches the resource being updated.\n\n\n// lib/policies/is-self.policy.js\n\nimport {ForbiddenError} from 'autonym-client-errors';\n\nfunction isSelf (req) {\n  if (req.query.userId !== req.resourceId) {\n    throw new ForbiddenError('You do not have permission to update this resource');\n  }\n}\n\nexport default isSelf;\n\n\n\n\nIn this contrived example, our way of telling if the current user is the user being updated, we're simply checking a\n\nuserId\n parameter in the query string. Horribly insecure, but easy to test. Note that we are throwing an instance of\n\nForbiddenError\n. It is important that your policy throw some subclass from the autonym-client-errors package, such as\n\nForbiddenError\n. If an internal error occurred (like a rejected database connection or a timeout), just throw it and\nAutonymResponder will return a 500 error and pass it onto your \nhandleError\n method; but if the error just indicates\nsomething the client did wrong, always make sure to throw a subclass of ClientError. You can read more about client\nerrors on \ntheir page\n.\n\n\nIt doesn't matter what the function \nreturns\n, unless it is a promise. If it's a promise, then the promise can resolve\nwith anything, or reject and it will be treated just like the throw example.\n\n\nYou may also have noticed the \nreq.resourceId\n property, which is nonstandard on the \nreq\n object in Express. Autonym\naggregates the \nreq\n object with many properties, which are documented on the \nreq \n res\n page.\n\n\nLet's attach this policy to the \nfindOneAndUpdate\n action, which we can do by modifying our schema.\n\n\n// lib/schemas/person.schema.json\n\n{\n  \nid\n: \nPerson\n,\n  \ntype\n: \nobject\n,\n  \npolicies\n: {\n    \nfindOneAndUpdate\n: \nisAdmin\n\n  },\n  \nproperties\n: {\n    \nfirstName\n: {\ntype\n: \nstring\n, \nminLength\n: 1, \nmaxLength\n: 20},\n    \nlastName\n: {\ntype\n: \nstring\n, \nminLength\n: 1, \nmaxLength\n: 20},\n    \nemployeeId\n: {\ntype\n: \nstring\n, \nminLength\n: 1, \nmaxLength\n: 10}\n  },\n  \nrequired\n: [\nfirstName\n, \nlastName\n, \nclientId\n]\n}\n\n\n\n\nNow if we reattempt a PATCH request on \n/people/42\n, we should get back a forbidden error. However, if try a request to\n\n/people/42?userId=42\n, we should get a success (assuming a person with id 42 exists). Obviously this is just a simple\nexample and not a valid means of authentication.\n\n\nThe \npolicies\n object on the schema can have \n*\n, \ncreate\n, \nfind\n, \nfindOne\n, \nfindOneAndUpdate\n, and\n\nfindOneAndDelete\n definitions. The \n*\n applies to \nall\n CRUD operations and is always evaluated first.\n\n\nThe values in the \npolicies\n object are actually \"asynchronous boolean expressions.\" At their simplest, they're just\nnames of policies. However, you can actually mix and match policies by using the syntax defined in\n\nasync-boolean-expression-evaluator\n. This allows you\nto combine policies, like \n{\"or\": [\"isAdmin\", \"isSelf\"]}\n or\n\n{\"and\": [\"isLoggedIn\", {\"or\": [\"isAdmin\", \"canChangePassword\"]}]}\n.\n\n\nAfterword\n\n\nHopefully this tutorial helped you get started with your first Autonym app! There's a lot more to it, and also a lot\nmore work for us to do. Please let us know what you think in the Issues section, and as always, pull requests are\nwelcome!", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "The quickest way to get started is by using the  Yeoman generator ,\nwhich scaffolds the structure of an Autonym app for you. However, this guide will take you through building an API from\nscratch, so we can walk through line by line how it works.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#prerequisites", 
            "text": "In these examples, we'll touch on each feature of Autonym by building an API for managing Person objects that are stored\nin a Postgres database. Needless to say, you'll want to have a recent version of Node/NPM installed as well as Postgres.  In addition, all examples of Autonym use features of ES6 that will require running with  Babel .\nThis tutorial does include what is needed to get a Babel application running, but we don't cover ES6 features here. We\nrecommend checking out  the ES6 features list by lukehoban  as a guide for any unfamiliar\nsyntax. You should also be comfortable with Express and understand concepts like middleware, request/response handling,\nand callbacks. Last, Autonym uses JSON schems. A complete example is included in this walkthrough, but you'll want to\nget comfortable writing your own schemas when you build a production API. We recommend the thorough documentation  provided by the Space Telescope\nScience Institute.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/getting-started/#installation", 
            "text": "Let's start with a totally blank application. Create a new directory, change into it, and  npm init  and follow the\nwizard to create a new  package.json  in your project.  Next, we'll install some dependencies to transpile the Babel source into ES5 at runtime. We'll also install nodemon , which is just a convenient tool that watches your source code for changes and\nautomatically restarts the API server.  mkdir new-api   cd $_\nnpm init\nnpm install --save-dev babel-cli babel-preset-node5 babel-preset-stage-2 nodemon  To run this app, you can use the  nodemon  executable instead of just  node . However, we want to override the command\nthat nodemon executes when the watched files change -- instead of running the  node  executable, it needs to run babel-node  to transpile our ES6.  Let's open up  package.json . Under the  scripts  section, we can add a  start  script that will serve as an aliased\nshortcut to our command.  scripts : {\n   start :  nodemon ./lib/app.js --exec babel-node \n}  The last thing we need to do is create a file called  .babelrc  in our project directory and populate it with:  {\n   presets : [ node5 ,  stage-2 ]\n}  This is enough to get a Babel app running; now let's install our normal dependencies. Autonym is just Express\nmiddleware, so we will need to install Express and its JSON-parsing companion body-parser. We'll install Autonym and the\nPostgres extension to make building models that connect to Postgres easier. Finally, we'll need some utility packages\nfor error handling; we'll cover what the last two dependencies are used for later in this guide.  npm install --save express body-parser autonym autonym-postgres-store autonym-client-errors instance-of-name", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/#coding", 
            "text": "Let's organize our app by placing source code in a  lib  directory, and we'll create the entry point to our app as app.js  like we specified in the  npm start  script.", 
            "title": "Coding"
        }, 
        {
            "location": "/getting-started/#a-simple-express-app", 
            "text": "In  lib/app.js  we'll start by just creating a typical Express server.  // lib/app.js\n\nimport express from 'express';\nimport bodyParser from 'body-parser';\nimport http from 'http';\n\nconst app = express();\napp.use(bodyParser.json({}));\n\napp.get('/', (req, res) =  res.json({message: 'Hello world!'}));\n\nhttp.createServer(app).listen(3000, err =  {\n  if (err) { throw err; }\n  console.log('Listening on port 3000');\n});  This is a bare-bones Express application. If you run this app with  npm start  and everything goes well, you'll see a Listening on port 3000  in your stdout. Visiting  http://localhost:3000/  in your browser or favorite REST client\n(we're fans of  Postman ) should yield the JSON  {\"message\":\"Hello world!\"} .", 
            "title": "A simple Express app"
        }, 
        {
            "location": "/getting-started/#refactoring-our-express-app", 
            "text": "Let's make a few improvements before we continue: we'll replace the literal  3000  with an environment variable so it\ncan be controlled by the service running our app. We'll replace  throw err;  with a reusable  handleError  function for\nour application. And we'll register a listener for the  unhandledRejection  event, which will fire if any promises throw\nexceptions that aren't caught elsewhere in the application (just in case -- Node swallows up unhandled promise\nrejections, unlike synchronous exceptions, which will crash the application).  // lib/app.js\n\nimport express from 'express';\nimport bodyParser from 'body-parser';\nimport http from 'http';\nimport handleError from './handle-error';\n\nprocess.on('unhandledRejection', handleError);\n\nconst app = express();\napp.use(bodyParser.json({}));\n\napp.get('/', (req, res) =  res.json({message: 'Hello world!'}));\n\nhttp.createServer(app).listen(process.env.PORT, err =  {\n  if (err) { return handleError(err); }\n  console.log(`Listening on port ${process.env.PORT}`);\n});  Now, of course,  PORT  is an environment variable, so we should export it or save it to our shell profile.  export PORT=3000  And we'll need to create our error handler as well, so create a new  handle-error.js .  This will just be a small file exporting a reusable function. This function will be called when errors occur and can\nchoose to log them out, send alerts to your on-call team, or crash the application.  For now, we're just going to throw the error, which will crash the app.  // lib/handle-error.js\n\nfunction handleError (err) {\n  setImmediate(() =  { throw err; });\n}\n\nexport default handleError;  Note that we wrapped it in a  setImmediate  call. This is because Express' default error when an exception is thrown\nduring a request is to catch it and pass it to a generic \"error middleware\", which simply logs the exception and carries\non. If an error makes it this far, we'd like to crash the app to reset its state. If we wrap the code in a setImmediate  call, it can't be caught by Express, since it will be thrown after Express finishes with the request.", 
            "title": "Refactoring our Express app"
        }, 
        {
            "location": "/getting-started/#integrating-autonym", 
            "text": "Alright, let's actually start integrating Autonym into our Express application.  Because Autonym is just Express middleware, we can simply add an  app.use()  call with a new instance of Autonym.  // lib/app.js\n\nimport express from 'express';\nimport bodyParser from 'body-parser';\nimport http from 'http';\nimport Autonym, {AutonymResponder} from 'autonym';\nimport handleError from './handle-error';\n\nprocess.on('unhandledRejection', handleError);\n\nconst app = express();\napp.use(bodyParser.json({}));\n\napp.get('/', (req, res) =  res.json({message: 'Hello world!'}));\n\napp.use(new Autonym(__dirname).middleware);\napp.use(new AutonymResponder(handleError).middleware);\n\nhttp.createServer(app).listen(process.env.PORT, err =  {\n  if (err) { return handleError(err); }\n  console.log(`Listening on port ${process.env.PORT}`);\n});  A few things are going on here:    We created a new instance of the  Autonym  class, passing  __dirname  into the constructor.  __dirname  is a Node.js\n  constant that refers to the absolute path to the currently executing file (i.e. the path to  ./lib ). Autonym will\n  attempt to import various \"components\" from this given directory by searching for files that match a pattern. Autonym\n  will read these components by a special set of rules, and you can find details about how it all works on the\n   Autonym page .    We mounted the  autonym.middleware  middleware onto the app. Now, all requests will pass through the instance of\n  Autonym at this stage in the middleware stack. Of course, since we mounted it after our  app.get()  middleware (which\n  does not call  next ), our hello world example will not pass through Autonym. The best way to adapt existing\n  applications with Autonym is to add the Autonym middleware near the bottom of the stack, so as to not affect existing\n  APIs.    We also mounted  new AutonymResponder(handleError).middleware . The  autonym.middleware  will validate and process the\n  request, but the  autonymResponder.middleware  middleware will actually send it to the client. These are deliberately\n  kept separate so that you can tweak the response however you like in between these two handlers. Note that the\n   AutonymResponder  constructor takes a  handleError  function. In addition to passing the error to the client, this\n  function can be used to capture and handle errors that happened during the request/response life cycle. More about the\n  AutonymResponder can be found on  its dedicated page .    Autonym is now going to look for files in the directory we passed into the constructor, in this case the absolute path\nto  ./lib . Autonym will check for three subdirectories in the path provided to it:  models ,  policies , and  schemas .\nGo ahead and create these three directories in the  lib  folder. Next, we'll describe and build each of these\ncomponents.", 
            "title": "Integrating Autonym"
        }, 
        {
            "location": "/getting-started/#our-first-model", 
            "text": "Let's create a model that represents a person. Models are just classes that extend from the  Model  abstract class that\nis exported by Autonym.  // lib/models/person.model.js\n\nimport {Model} from 'autonym';\n\nclass Person extends Model {\n}\n\nexport default Person;  This model doesn't do much yet! But, if we create some static methods with specific names, we can start to add\nfunctionality to our model. Let's start with the  _find()  method, which should return a list of people.  // lib/models/person.model.js\n\nimport {Model} from 'autonym';\n\nclass Person extends Model {\n  static _find (query) {\n    return Promise.resolve([\n      {\n        id: '1',\n        firstName: 'John',\n        lastName: 'Galt',\n        employerId: '42'\n      }\n    ]);\n  }\n}\n\nexport default Person;  By defining this function, we've now added the ability for our API to \"get people.\" The abstract Model class noticed\nthat the  _find()  function was defined, so it will call it any time you make a GET request to  /people . Your function must  return a promise and that promise  must  pass back an array. For now, that array is just static data.  There are four other CRUD methods ( _create() ,  _findOne() ,  _findOneAndUpdate() ,  _findOneAndDelete() ) which are\ndescribed in more detail in the  Model API . Note that if any of them aren't set on your\nmodel, it's okay -- your user will just receive a method not allowed error. However, note that  _findOne()   must  be\nset up in order for  _findOneAndUpdate()  and  _findOneAndDelete()  to work.  Go ahead! Hit  http://localhost:3000/people  in your browser or Postman and you should get back the array.  Behind the scenes, Autonym processes a GET request, parses the incoming data, forwards the relevant parts of the request\nto  _find() , then reformats the results and passes them onto the next middleware in the stack. In this case, the next\nmiddleware is the AutonymResponder, which just returns the response. However, if you wanted to, for example, wrap that\narray inside an object (e.g.  {\"data\": []} ) or add some specific headers, you could add more middleware in between --\nall Autonym does is add some properties to the  req  and  res  objects from Express with additional information. More\ninformation about how this works and how to hook into this process is available in the API section.", 
            "title": "Our first model"
        }, 
        {
            "location": "/getting-started/#using-the-postgres-store", 
            "text": "We could define the additional methods like  _create()  and  _findOne() , but that might seem tedious. If we had a\ncustom datastore, we might implement these methods manually. But since we're using Postgres, we can automate that work.  First, let's create a Postgres database and add a new table to hold people. Let's create a Postgres database and a new\ntable.  createdb autonym_app\npsql autonym_app  CREATE TABLE people (\n  id BIGSERIAL PRIMARY KEY,\n  first_name VARCHAR(255) NOT NULL,\n  last_name VARCHAR(255) NOT NULL,\n  employer_id BIGINT NOT NULL\n);  Note that the primary key has to be a column called  id  for Autonym to work.  We also need to tell Autonym how to connect to our Postgres store. This is done with another environment variable, so\nyou let's export another environment variable.  export POSTGRES_CONNECTION= postgres://$USER@localhost:5432/autonym_app   Now we can leverage the Postgres store extension in our model.  // lib/models/person.model.js\n\nimport {Model} from 'autonym';\nimport PostgresStoreFactory from 'autonym-postgres-store';\n\nconst PostgresStore = PostgresStoreFactory();\n\nclass Person extends Model {\n  static _init () {\n    this.store = new PostgresStore('people');\n    super._implementDefaultStoreCrudMethods(this.store);\n  }\n}\n\nexport default Person;  Here, we've attached a static  _init()  method. It creates a new property on the class called  store  and instantiates a PostgresStore , passing in the name of our table. Then, we call  _implementDefaultStoreCrudMethods() , which is a\nfunction on the abstract Model class, providing our store instance. All this fancy function does is copy the  create() , find() ,  findOne() ,  findOneAndUpdate() ,  findOneAndDelete() ,  serialize() , and  unserialize()  functions from the\nstore to our model class. This is basically just a quicker way of doing something like:  static _create () { return this.store.create(...arguments); }\nstatic _find () { return this.store.find(...arguments); }\nstatic _findOne () { return this.store.findOne(...arguments); }\n// ...  At this point, we've essentially defined our Person model, and it's fully integrated with Postgres. Using a REST client,\ntry some requests:   POST http://localhost:3000/people   Request  { firstName : John , lastName : Galt , employerId : 42 }  Response  { id :1, firstName : John , lastName : Galt , employerId : 42 }   POST http://localhost:3000/people   Request  { firstName : Dagny , lastName : Taggart , employerId : 42 }  Response  { id :2, firstName : Dagny , lastName : Taggart , employerId : 42 }   GET http://localhost:3000/people   Response  [{ id :1, firstName : John , lastName : Galt , employerId : 42 },{ id :2, firstName : Dagny , lastName : Taggart , employerId : 42 }]   GET http://localhost:3000/people/1   Response  { id :1, firstName : John , lastName : Galt , employerId : 42 }   PATCH http://localhost:3000/people/2   Request  { lastName : Galt }  Response  { id :2, firstName : Dagny , lastName : Galt , employerId : 42 }   GET http://localhost:3000/people?search[firstName][~]=dag   Response  [{ id :2, firstName : Dagny , lastName : Galt , employerId : 42 }]   GET http://localhost:3000/people?sort=+firstName   Response  [{ id :2, firstName : Dagny , lastName : Galt , employerId : 42 },{ id :1, firstName : John , lastName : Galt , employerId : 42 }]   DELETE http://localhost:3000/people/1   Response  no content", 
            "title": "Using the Postgres Store"
        }, 
        {
            "location": "/getting-started/#adding-a-json-schema", 
            "text": "So there we have a working model! However, you should probably see in your stdout a warning about missing a schema.\nWithout JSON schema validation, this is a huge security violation. Any data can be sent to our API and the Postgres\nstore will try to insert it, even if the columns don't exist, are of the wrong type, or worse -- are columns users\nshouldn't be allowed to write to (like  id )!  Let's create a JSON schema for our Person model. Properties that aren't defined in the schema will be automatically\ndiscarded from the request, and the defined properties will be properly validated.  // lib/schemas/person.schema.json\n\n{\n   id :  Person ,\n   type :  object ,\n   properties : {\n     firstName : { type :  string ,  minLength : 1,  maxLength : 20},\n     lastName : { type :  string ,  minLength : 1,  maxLength : 20},\n     employerId : { type :  string ,  minLength : 1,  maxLength : 10}\n  },\n   required : [ firstName ,  lastName ,  employerId ]\n}  Now, JSON schema validation will be properly enforced against any operations to the model. The schema is automatically\nmatched to the model because its  id  is  Person , which is the same as the name of our model.  If you try sending an invalid request, you'll notice your app crashes. That's because the  handleError  method is\ncrashing it when  any  error occurs. Let's make some adjustments.  // lib/handle-error.js\n\nimport instanceOf from 'instance-of-name';\n\nfunction handleError (err) {\n  if ('internalQuery' in err) {\n    console.error(err);\n  } else if (instanceOf(err, 'ClientError')) {\n    console.log(err.message);\n  } else {\n    setImmediate(() =  { throw err; });\n  }\n}\n\nexport default handleError;  Here we'll walk through some changes we made:   We're \"duck-typing\" the error to see if it has an  internalQuery  property. If that property exists, it probably means\n  the error originated from the Postgres database driver. This could mean something bad, but generally an erroneous\n  query doesn't mean the app has to crash, it might be due to a misconfigured model or a search query that just wouldn't\n  work. Let's log it out to stderr, but we'll keep the app going.  The next condition checks if the error was derived from a class called  ClientError .  ClientError  is a special class\n  that Autonym uses for any errors that are the result of a bad request on behalf of the client. The app is totally fine,\n  but the user got back an error message. Here, we're printing it out just for verbosity, but we could safely ignore\n  these errors. You can read more about client errors  on their respective page .  Otherwise we'll continue with our default behavior and crash the app.", 
            "title": "Adding a JSON schema"
        }, 
        {
            "location": "/getting-started/#creating-a-policy", 
            "text": "The last feature we'll explore in this guide is policies. Policies are a lot like Express middleware and are simply\nfunctions that perform sanitization and validation on requests that are beyond the capabilities of JSON schemas. Common\nfunctions of policies are:   add a timestamp to every resource  add hard-coded filters to searches to restrict result sets  validate that the user has permission to perform the action   We're going to only allow people to make updates if they are editing themselves. Let's create a policy that checks some\nproperty on the request to see if it matches the resource being updated.  // lib/policies/is-self.policy.js\n\nimport {ForbiddenError} from 'autonym-client-errors';\n\nfunction isSelf (req) {\n  if (req.query.userId !== req.resourceId) {\n    throw new ForbiddenError('You do not have permission to update this resource');\n  }\n}\n\nexport default isSelf;  In this contrived example, our way of telling if the current user is the user being updated, we're simply checking a userId  parameter in the query string. Horribly insecure, but easy to test. Note that we are throwing an instance of ForbiddenError . It is important that your policy throw some subclass from the autonym-client-errors package, such as ForbiddenError . If an internal error occurred (like a rejected database connection or a timeout), just throw it and\nAutonymResponder will return a 500 error and pass it onto your  handleError  method; but if the error just indicates\nsomething the client did wrong, always make sure to throw a subclass of ClientError. You can read more about client\nerrors on  their page .  It doesn't matter what the function  returns , unless it is a promise. If it's a promise, then the promise can resolve\nwith anything, or reject and it will be treated just like the throw example.  You may also have noticed the  req.resourceId  property, which is nonstandard on the  req  object in Express. Autonym\naggregates the  req  object with many properties, which are documented on the  req   res  page.  Let's attach this policy to the  findOneAndUpdate  action, which we can do by modifying our schema.  // lib/schemas/person.schema.json\n\n{\n   id :  Person ,\n   type :  object ,\n   policies : {\n     findOneAndUpdate :  isAdmin \n  },\n   properties : {\n     firstName : { type :  string ,  minLength : 1,  maxLength : 20},\n     lastName : { type :  string ,  minLength : 1,  maxLength : 20},\n     employeeId : { type :  string ,  minLength : 1,  maxLength : 10}\n  },\n   required : [ firstName ,  lastName ,  clientId ]\n}  Now if we reattempt a PATCH request on  /people/42 , we should get back a forbidden error. However, if try a request to /people/42?userId=42 , we should get a success (assuming a person with id 42 exists). Obviously this is just a simple\nexample and not a valid means of authentication.  The  policies  object on the schema can have  * ,  create ,  find ,  findOne ,  findOneAndUpdate , and findOneAndDelete  definitions. The  *  applies to  all  CRUD operations and is always evaluated first.  The values in the  policies  object are actually \"asynchronous boolean expressions.\" At their simplest, they're just\nnames of policies. However, you can actually mix and match policies by using the syntax defined in async-boolean-expression-evaluator . This allows you\nto combine policies, like  {\"or\": [\"isAdmin\", \"isSelf\"]}  or {\"and\": [\"isLoggedIn\", {\"or\": [\"isAdmin\", \"canChangePassword\"]}]} .", 
            "title": "Creating a policy"
        }, 
        {
            "location": "/getting-started/#afterword", 
            "text": "Hopefully this tutorial helped you get started with your first Autonym app! There's a lot more to it, and also a lot\nmore work for us to do. Please let us know what you think in the Issues section, and as always, pull requests are\nwelcome!", 
            "title": "Afterword"
        }, 
        {
            "location": "/req-and-res/", 
            "text": "req \n res\n\n\nAutonym adds some properties to the request and response objects used in Express middleware as a convenience. These are\nlisted here for reference. They can be accessed in middleware that follows after Autonym has been executed on the\nrequest. In addition, the fully hydrated \nreq\n object is passed into policies.\n\n\nreq\n\n\ndata\n\n\nreq.data\n is a plain object that contains the validated and filtered body of the request. This is passed to the create\nand update actions.\n\n\ncompleteResource\n\n\nreq.completeResource\n is only defined for the update action. Like \nreq.data\n, it is a plain object, but it represents\nthe complete resource to be updated, rather than just the partial resource passed to the API. This is useful if you need\nto set criteria in a query, if you need to perform policy validation on other parts of the resource, or your data store\nrequires a complete swap of the document.\n\n\nfilter\n\n\nreq.filter\n is an array that always starts off empty but can be pushed to by policies. It is passed to all of the CRUD\nactions on the model. It is useful for things like restricting the result set to only records the user has permission to\nview or edit, or force the property of all records to a static value. It is up to the model (or store) to implement the\nfilter.\n\n\nThere is no predefined format for an element in the filter array, as how filters are used depends on the model's\ninterpretation. The \nautonym-postgres-store\n, as an example,\ndefines a filter as an object with \nfield\n, \nvalue\n, and \noperator\n keys, e.g.\n\n{field: 'employerId', value: '42', operator: '='}\n, and the store converts these into conditions in a SQL query, joined\nby \nAND\n. Other models or their underlying stores may implement a different definition for a filter.\n\n\nmodels\n\n\nreq.models\n is a list of all the models registered in the Autonym application. This is especially useful if you need to\ndo cross-model validation. Use the public methods on other models, e.g. \nreq.models.Person.findOne('123').then(...)\n.\n(By \"public methods\" we mean methods not prefixed by an underscore. These methods are inherited from the abstract\n\nModel\n class and wrap the internal underscore-prefixed methods with pre- and post-hooks, such as schema and policy\nvalidation.)\n\n\nModel\n\n\nreq.Model\n is the class for the current model that the action is performed against. This is useful if a policy is\nshared by multiple models but needs to perform an action against the current model being validated. Use the public\nmethods, e.g. \nreq.Model.findOne(123).then(...)\n.\n\n\ncrudMethod\n\n\nreq.crudMethod\n is set to one of \ncreate\n, \nfind\n, \nfindOne\n, \nfindOneAndUpdate\n, or \nfindOneAndDelete\n, based on the\nrequest type.\n\n\nresourceId\n\n\nreq.resourceId\n is set to the resource id for \nfindOne\n, \nfindOneAndUpdate\n, and \nfindOneAndDelete\n actions. Otherwise\nit is \nnull\n. Note that the id is always a string, so be careful when making strict comparisons if your store uses\nnumber types.\n\n\ngetting\n\n\nreq.getting\n is \ntrue\n for \nfind\n and \nfindOne\n requests.\n\n\nfinding\n\n\nreq.finding\n is \ntrue\n for \nfind\n requests only.\n\n\nfindingOne\n\n\nreq.findingOne\n is \ntrue\n for \nfindOne\n, \nfindOneAndUpdate\n, and \nfindOneAndDelete\n requests.\n\n\ncreating\n\n\nreq.creating\n is \ntrue\n for \ncreate\n requests only.\n\n\nupdating\n\n\nreq.updating\n is \ntrue\n for \nfindOneAndUpdate\n requests only.\n\n\ndeleting\n\n\nreq.deleting\n is \ntrue\n for \nfindOneAndDelete\n requests only.\n\n\nhasBody\n\n\nreq.hasBody\n is \ntrue\n for \ncreate\n and \nfindOneAndUpdate\n requests.\n\n\nwriting\n\n\nreq.writing\n is \ntrue\n for \ncreate\n, \nfindOneAndUpdate\n, and \nfindOneAndDelete\n requests.\n\n\nreading\n\n\nreq.reading\n is \ntrue\n for \ncreate\n, \nfind\n, \nfindOne\n, and \nfindOneAndUpdate\n requests.\n\n\nres\n\n\ndata\n\n\nres.data\n is set to the data that should be sent in the response, and must be JSON-serializable. It is \nnull\n for\n\nfindOneAndDelete\n requests. It may contain a representation of a resource, an array of resources, or details about an\nerror that occurred.", 
            "title": "req & res"
        }, 
        {
            "location": "/req-and-res/#req-res", 
            "text": "Autonym adds some properties to the request and response objects used in Express middleware as a convenience. These are\nlisted here for reference. They can be accessed in middleware that follows after Autonym has been executed on the\nrequest. In addition, the fully hydrated  req  object is passed into policies.", 
            "title": "req &amp; res"
        }, 
        {
            "location": "/req-and-res/#req", 
            "text": "", 
            "title": "req"
        }, 
        {
            "location": "/req-and-res/#data", 
            "text": "req.data  is a plain object that contains the validated and filtered body of the request. This is passed to the create\nand update actions.", 
            "title": "data"
        }, 
        {
            "location": "/req-and-res/#completeresource", 
            "text": "req.completeResource  is only defined for the update action. Like  req.data , it is a plain object, but it represents\nthe complete resource to be updated, rather than just the partial resource passed to the API. This is useful if you need\nto set criteria in a query, if you need to perform policy validation on other parts of the resource, or your data store\nrequires a complete swap of the document.", 
            "title": "completeResource"
        }, 
        {
            "location": "/req-and-res/#filter", 
            "text": "req.filter  is an array that always starts off empty but can be pushed to by policies. It is passed to all of the CRUD\nactions on the model. It is useful for things like restricting the result set to only records the user has permission to\nview or edit, or force the property of all records to a static value. It is up to the model (or store) to implement the\nfilter.  There is no predefined format for an element in the filter array, as how filters are used depends on the model's\ninterpretation. The  autonym-postgres-store , as an example,\ndefines a filter as an object with  field ,  value , and  operator  keys, e.g. {field: 'employerId', value: '42', operator: '='} , and the store converts these into conditions in a SQL query, joined\nby  AND . Other models or their underlying stores may implement a different definition for a filter.", 
            "title": "filter"
        }, 
        {
            "location": "/req-and-res/#models", 
            "text": "req.models  is a list of all the models registered in the Autonym application. This is especially useful if you need to\ndo cross-model validation. Use the public methods on other models, e.g.  req.models.Person.findOne('123').then(...) .\n(By \"public methods\" we mean methods not prefixed by an underscore. These methods are inherited from the abstract Model  class and wrap the internal underscore-prefixed methods with pre- and post-hooks, such as schema and policy\nvalidation.)", 
            "title": "models"
        }, 
        {
            "location": "/req-and-res/#model", 
            "text": "req.Model  is the class for the current model that the action is performed against. This is useful if a policy is\nshared by multiple models but needs to perform an action against the current model being validated. Use the public\nmethods, e.g.  req.Model.findOne(123).then(...) .", 
            "title": "Model"
        }, 
        {
            "location": "/req-and-res/#crudmethod", 
            "text": "req.crudMethod  is set to one of  create ,  find ,  findOne ,  findOneAndUpdate , or  findOneAndDelete , based on the\nrequest type.", 
            "title": "crudMethod"
        }, 
        {
            "location": "/req-and-res/#resourceid", 
            "text": "req.resourceId  is set to the resource id for  findOne ,  findOneAndUpdate , and  findOneAndDelete  actions. Otherwise\nit is  null . Note that the id is always a string, so be careful when making strict comparisons if your store uses\nnumber types.", 
            "title": "resourceId"
        }, 
        {
            "location": "/req-and-res/#getting", 
            "text": "req.getting  is  true  for  find  and  findOne  requests.", 
            "title": "getting"
        }, 
        {
            "location": "/req-and-res/#finding", 
            "text": "req.finding  is  true  for  find  requests only.", 
            "title": "finding"
        }, 
        {
            "location": "/req-and-res/#findingone", 
            "text": "req.findingOne  is  true  for  findOne ,  findOneAndUpdate , and  findOneAndDelete  requests.", 
            "title": "findingOne"
        }, 
        {
            "location": "/req-and-res/#creating", 
            "text": "req.creating  is  true  for  create  requests only.", 
            "title": "creating"
        }, 
        {
            "location": "/req-and-res/#updating", 
            "text": "req.updating  is  true  for  findOneAndUpdate  requests only.", 
            "title": "updating"
        }, 
        {
            "location": "/req-and-res/#deleting", 
            "text": "req.deleting  is  true  for  findOneAndDelete  requests only.", 
            "title": "deleting"
        }, 
        {
            "location": "/req-and-res/#hasbody", 
            "text": "req.hasBody  is  true  for  create  and  findOneAndUpdate  requests.", 
            "title": "hasBody"
        }, 
        {
            "location": "/req-and-res/#writing", 
            "text": "req.writing  is  true  for  create ,  findOneAndUpdate , and  findOneAndDelete  requests.", 
            "title": "writing"
        }, 
        {
            "location": "/req-and-res/#reading", 
            "text": "req.reading  is  true  for  create ,  find ,  findOne , and  findOneAndUpdate  requests.", 
            "title": "reading"
        }, 
        {
            "location": "/req-and-res/#res", 
            "text": "", 
            "title": "res"
        }, 
        {
            "location": "/req-and-res/#data_1", 
            "text": "res.data  is set to the data that should be sent in the response, and must be JSON-serializable. It is  null  for findOneAndDelete  requests. It may contain a representation of a resource, an array of resources, or details about an\nerror that occurred.", 
            "title": "data"
        }, 
        {
            "location": "/autonym/", 
            "text": "Autonym\n\n\nThe Autonym class creates a new middleware instance that can be mounted to your Express application.\n\n\nConstructor arguments\n\n\nThe first argument to the constructor is typically the absolute path to the location of your \nmodels\n, \nschemas\n, and\n\npolicies\n directories. For instance, if the file where you instantiate Autonym is located at \n/home/jgalt/app/app.js\n\nand your Autonym components live in \n/home/jgalt/app/auto/models\n, \n/home/jgalt/app/auto/schemas\n, and\n\n/home/jgalt/app/auto/policies\n, then you would pass in \n__dirname + '/auto'\n.\n\n\nInside these directories, Autonym will load files if their names match these patterns:\n\n\n\n\nModels:\n \n^models/(.+)\\.model\\.js$\n (i.e. anything in the \nmodels\n directory named \nANYTHING.model.js\n)\n\n\nSchemas:\n \n^schemas/(.+)\\.schema\\.json$\n (i.e. anything in the \nschemas\n directory named \nANYTHING.schema.json\n)\n\n\nPolicies:\n \n^policies/(.+)\\.policy\\.js$\n (i.e. anything in the \npolicies\n directory named \nANYTHING.policy.js\n)\n\n\n\n\nSometimes, the directory-based setup may not work for your application. For example, maybe you need to fetch your\nschemas from another API and pass them in instead of pulling them directly off the filesystem. In this case, you can\ninstantiate Autonym by passing the three kinds of components directly into the constructor, like the following example.\n\n\nnew Autonym({\n  models: {\n    Person: class Person extends Model {...}\n  },\n  schemas: {\n    Person: {id: 'Person', type: 'object', ...}\n  },\n  policies: {\n    isLoggedIn: function isLoggedIn (req) {...}\n  }\n});\n\n\n\n\nHow components are named\n\n\nIt is important to understand the rules behind how components are named and referenced in the Autonym application.\n\n\nModels\n\n\nModels are referenced by the name of the class that the model file exports. So for instance, if you write:\n\n\nclass Person extends Model { }\n\nexport default Person;\n\n\n\n\nThen the model will be referenced by the name \nPerson\n. This is important to note, as if two model files export a class\nwith the same name, \nthe latter will overwrite the former\n. The Autonym convention is to always export a named class\nto reduce ambiguity, but take care to name your classes uniquely!\n\n\nYou can also export an anonymous class, e.g.:\n\n\nexport default class extends Model { };\n\n\n\n\nIn this case, the filename will be converted to PascalCase and used as the identifier, e.g. \nuser-group.model.js\n will\nresult in a model named \nUserGroup\n. If Autonym is instantiated with component references instead of a path, then the\nkey on the models object will be used as the identifier, e.g. \n{models: {UserGroup: class extends Model {...}}\n will\nresult in a model named \nUserGroup\n.\n\n\nSchemas\n\n\nSchemas are referenced by the \nid\n property on the schema. So, for instance, if you write:\n\n\n{\n  \nid\n: \nPerson\n,\n  \ntype\n: \nobject\n,\n  ...\n}\n\n\n\n\nThen the schema will be referenced by the name \nPerson\n. \nTo match a schema with a model, the \nid\n of the schema\n\nmust\n match the model's resolved name.\n\n\nLike models, it is important that no two schemas are assigned the same \nid\n, as the latter will overwrite the former.\nThe Autonym convention is to always export a named schema to reduce ambiguity, but take care to name your schemas\nuniquely!\n\n\nYou can also omit the \nid\n property from the schema. In this case, the \nid\n will resolve to the filename converted to\nPascalCase, e.g. \nuser-group.schema.json\n will result in a schema named \nUserGroup\n. If Autonym is instantiated with\ncomponent references instead of a path, then the key on the schemas object will be used as the identifier, e.g.\n\n{schemas: {UserGroup: {type: 'object', ...}}}\n will result in a schema named \nUserGroup\n.\n\n\nPolicies\n\n\nPolicies are referenced by the name of the function that the policy file exports. So for instance, if you write:\n\n\nfunction isLoggedIn (req) {\n  ...\n}\n\nexport default isLoggedIn;\n\n\n\n\nThen the policy will be referenced by the name \nisLoggedIn\n. Like models and schemas, ensure that every policy is named\nuniquely, as latter policies will overwrite former policies if they are named the same. The Autonym convention is to\nalways export a named function to reduce ambiguity, but take care to name your policies uniquely!\n\n\nYou can also export an anonymous function, e.g.:\n\n\nexport default function (req) {\n  ...\n};\n\n\n\n\nIn this case, the name will resolve to the filename converted to camelCase, e.g. \nis-logged-in.policy.js\n will result in\na policy named \nisLoggedIn\n. If Autonym is instantiated with component references instead of a path, then the key on the\npolicies object will be used as the identifier, e.g. \n{policies: {isLoggedIn: function (req) { ... }}}\n will result in a\npolicy named \nisLoggedIn\n.\n\n\nAutonym API\n\n\n#constructor(components)\n\n\nCreates a new instance of Autonym, accepting either an absolute path to a directory containing subdirectories for\nmodels, schemas, and policies, or an object with properties named \nmodels\n, \nschemas\n, and \npolicies\n whose values are\ncollections of the specified component type.\n\n\n.loadFromPath(dirname)\n\n\nAccepts an absolute path to a directory containing subdirectories for models, schemas, and policies. Synchronously\nrequires the components in these subdirectories and returns an object in the alternate format the constructor accepts,\ni.e. an object with \nmodels\n, \nschemas\n, and \npolicies\n which map to collections of components.\n\n\n#modelsInitialized\n\n\nA promise that resolves when all the given models have finished initializing. Note that it is possible to dynamically\nadd models to Autonym at runtime but they should be manually initialized first. This promise only applies to the models\nthat were attached when the instance was constructed.\n\n\n#models\n\n\nThe models attached to this instance of Autonym. You can dynamically add models to this object at runtime if they are\nalready initialized, and they are named, not anonymous.\n\n\n#schemas\n\n\nThe schemas attached to this instance of Autonym. You can dynamically add schemas to this object at runtime if they have\nan \nid\n property set.\n\n\n#policies\n\n\nThe policies attached to this instance of Autonym. You can dynamically add policies to this object at runtime if they\nare named, not anonymous.\n\n\n#middleware\n\n\nExpress middleware that must be mounted to your application.\n\n\n#modelRouter\n\n\nProvides direct access to the instance of ModelRouter, which handles requests and maps them to model CRUD actions.\n\n\n#errorRouter\n\n\nProvides direct access to the instance of ErrorRouter, which handles exceptions raised in the ModelRouter and prepares\nthe response.", 
            "title": "Autonym"
        }, 
        {
            "location": "/autonym/#autonym", 
            "text": "The Autonym class creates a new middleware instance that can be mounted to your Express application.", 
            "title": "Autonym"
        }, 
        {
            "location": "/autonym/#constructor-arguments", 
            "text": "The first argument to the constructor is typically the absolute path to the location of your  models ,  schemas , and policies  directories. For instance, if the file where you instantiate Autonym is located at  /home/jgalt/app/app.js \nand your Autonym components live in  /home/jgalt/app/auto/models ,  /home/jgalt/app/auto/schemas , and /home/jgalt/app/auto/policies , then you would pass in  __dirname + '/auto' .  Inside these directories, Autonym will load files if their names match these patterns:   Models:   ^models/(.+)\\.model\\.js$  (i.e. anything in the  models  directory named  ANYTHING.model.js )  Schemas:   ^schemas/(.+)\\.schema\\.json$  (i.e. anything in the  schemas  directory named  ANYTHING.schema.json )  Policies:   ^policies/(.+)\\.policy\\.js$  (i.e. anything in the  policies  directory named  ANYTHING.policy.js )   Sometimes, the directory-based setup may not work for your application. For example, maybe you need to fetch your\nschemas from another API and pass them in instead of pulling them directly off the filesystem. In this case, you can\ninstantiate Autonym by passing the three kinds of components directly into the constructor, like the following example.  new Autonym({\n  models: {\n    Person: class Person extends Model {...}\n  },\n  schemas: {\n    Person: {id: 'Person', type: 'object', ...}\n  },\n  policies: {\n    isLoggedIn: function isLoggedIn (req) {...}\n  }\n});", 
            "title": "Constructor arguments"
        }, 
        {
            "location": "/autonym/#how-components-are-named", 
            "text": "It is important to understand the rules behind how components are named and referenced in the Autonym application.", 
            "title": "How components are named"
        }, 
        {
            "location": "/autonym/#models", 
            "text": "Models are referenced by the name of the class that the model file exports. So for instance, if you write:  class Person extends Model { }\n\nexport default Person;  Then the model will be referenced by the name  Person . This is important to note, as if two model files export a class\nwith the same name,  the latter will overwrite the former . The Autonym convention is to always export a named class\nto reduce ambiguity, but take care to name your classes uniquely!  You can also export an anonymous class, e.g.:  export default class extends Model { };  In this case, the filename will be converted to PascalCase and used as the identifier, e.g.  user-group.model.js  will\nresult in a model named  UserGroup . If Autonym is instantiated with component references instead of a path, then the\nkey on the models object will be used as the identifier, e.g.  {models: {UserGroup: class extends Model {...}}  will\nresult in a model named  UserGroup .", 
            "title": "Models"
        }, 
        {
            "location": "/autonym/#schemas", 
            "text": "Schemas are referenced by the  id  property on the schema. So, for instance, if you write:  {\n   id :  Person ,\n   type :  object ,\n  ...\n}  Then the schema will be referenced by the name  Person .  To match a schema with a model, the  id  of the schema must  match the model's resolved name.  Like models, it is important that no two schemas are assigned the same  id , as the latter will overwrite the former.\nThe Autonym convention is to always export a named schema to reduce ambiguity, but take care to name your schemas\nuniquely!  You can also omit the  id  property from the schema. In this case, the  id  will resolve to the filename converted to\nPascalCase, e.g.  user-group.schema.json  will result in a schema named  UserGroup . If Autonym is instantiated with\ncomponent references instead of a path, then the key on the schemas object will be used as the identifier, e.g. {schemas: {UserGroup: {type: 'object', ...}}}  will result in a schema named  UserGroup .", 
            "title": "Schemas"
        }, 
        {
            "location": "/autonym/#policies", 
            "text": "Policies are referenced by the name of the function that the policy file exports. So for instance, if you write:  function isLoggedIn (req) {\n  ...\n}\n\nexport default isLoggedIn;  Then the policy will be referenced by the name  isLoggedIn . Like models and schemas, ensure that every policy is named\nuniquely, as latter policies will overwrite former policies if they are named the same. The Autonym convention is to\nalways export a named function to reduce ambiguity, but take care to name your policies uniquely!  You can also export an anonymous function, e.g.:  export default function (req) {\n  ...\n};  In this case, the name will resolve to the filename converted to camelCase, e.g.  is-logged-in.policy.js  will result in\na policy named  isLoggedIn . If Autonym is instantiated with component references instead of a path, then the key on the\npolicies object will be used as the identifier, e.g.  {policies: {isLoggedIn: function (req) { ... }}}  will result in a\npolicy named  isLoggedIn .", 
            "title": "Policies"
        }, 
        {
            "location": "/autonym/#autonym-api", 
            "text": "", 
            "title": "Autonym API"
        }, 
        {
            "location": "/autonym/#constructorcomponents", 
            "text": "Creates a new instance of Autonym, accepting either an absolute path to a directory containing subdirectories for\nmodels, schemas, and policies, or an object with properties named  models ,  schemas , and  policies  whose values are\ncollections of the specified component type.", 
            "title": "#constructor(components)"
        }, 
        {
            "location": "/autonym/#loadfrompathdirname", 
            "text": "Accepts an absolute path to a directory containing subdirectories for models, schemas, and policies. Synchronously\nrequires the components in these subdirectories and returns an object in the alternate format the constructor accepts,\ni.e. an object with  models ,  schemas , and  policies  which map to collections of components.", 
            "title": ".loadFromPath(dirname)"
        }, 
        {
            "location": "/autonym/#modelsinitialized", 
            "text": "A promise that resolves when all the given models have finished initializing. Note that it is possible to dynamically\nadd models to Autonym at runtime but they should be manually initialized first. This promise only applies to the models\nthat were attached when the instance was constructed.", 
            "title": "#modelsInitialized"
        }, 
        {
            "location": "/autonym/#models_1", 
            "text": "The models attached to this instance of Autonym. You can dynamically add models to this object at runtime if they are\nalready initialized, and they are named, not anonymous.", 
            "title": "#models"
        }, 
        {
            "location": "/autonym/#schemas_1", 
            "text": "The schemas attached to this instance of Autonym. You can dynamically add schemas to this object at runtime if they have\nan  id  property set.", 
            "title": "#schemas"
        }, 
        {
            "location": "/autonym/#policies_1", 
            "text": "The policies attached to this instance of Autonym. You can dynamically add policies to this object at runtime if they\nare named, not anonymous.", 
            "title": "#policies"
        }, 
        {
            "location": "/autonym/#middleware", 
            "text": "Express middleware that must be mounted to your application.", 
            "title": "#middleware"
        }, 
        {
            "location": "/autonym/#modelrouter", 
            "text": "Provides direct access to the instance of ModelRouter, which handles requests and maps them to model CRUD actions.", 
            "title": "#modelRouter"
        }, 
        {
            "location": "/autonym/#errorrouter", 
            "text": "Provides direct access to the instance of ErrorRouter, which handles exceptions raised in the ModelRouter and prepares\nthe response.", 
            "title": "#errorRouter"
        }, 
        {
            "location": "/autonym-responder/", 
            "text": "AutonymResponder\n\n\nThe AutonymResponder will dispatch a response to the client. Once Autonym has finished handling the request, it sets\nsome properties on the \nreq\n object (or passes an error along) which will be consumed by the AutonymResponder, which\ndetermines what response to send. AutonymResponder will also try to determine if any error was due to bad client data or\nan issue on your server and send the appropriate response.\n\n\nConstructor arguments\n\n\nThe AutonymResponder constructor takes one optional argument, which is a function to handle errors. The function is\nexecuted any time an error occurs (whether it is a client or system error) so that your app can take appropriate action,\nsuch as logging the event, triggering an alert, or crashing and restarting.\n\n\nThis function just takes the error object as its only parameter.\n\n\nIf no argument is supplied, then Autonym will simply pass the error to the next error-handling middleware in the Express\nstack. Often this handler is the default one provided by Express, which will log the exception to stderr and carry on.\n\n\nWhat the middleware does with the response\n\n\nIf an error occurred, the error handler function will be passed the error. If there was no error handler function\nprovided, it will pass the error to the next middleware.\n\n\nIf the response is not already sent, then AutonymResponder will:\n\n\n\n\nCheck for a property named \ndata\n on the response object.\n\n\nIf it exists and is not null, it will send the response, with a JSON body set to the value of \nres.data\n.\n\n\nIf \nres.data\n is null, it will send the response with no body.\n\n\n\n\n\n\nOtherwise, it will return a 404 error.\n\n\n\n\nAutonymResponder API\n\n\n#constructor(handleError)\n\n\nCreates a new instance of AutonymResponder, optionally taking a function to handle errors.\n\n\n#handleError\n\n\nThe function supplied to the constructor, or \nundefined\n. Can be changed at runtime.\n\n\n#middleware\n\n\nExpress middleware that can be mounted to your application to send the response and capture errors.", 
            "title": "AutonymResponder"
        }, 
        {
            "location": "/autonym-responder/#autonymresponder", 
            "text": "The AutonymResponder will dispatch a response to the client. Once Autonym has finished handling the request, it sets\nsome properties on the  req  object (or passes an error along) which will be consumed by the AutonymResponder, which\ndetermines what response to send. AutonymResponder will also try to determine if any error was due to bad client data or\nan issue on your server and send the appropriate response.", 
            "title": "AutonymResponder"
        }, 
        {
            "location": "/autonym-responder/#constructor-arguments", 
            "text": "The AutonymResponder constructor takes one optional argument, which is a function to handle errors. The function is\nexecuted any time an error occurs (whether it is a client or system error) so that your app can take appropriate action,\nsuch as logging the event, triggering an alert, or crashing and restarting.  This function just takes the error object as its only parameter.  If no argument is supplied, then Autonym will simply pass the error to the next error-handling middleware in the Express\nstack. Often this handler is the default one provided by Express, which will log the exception to stderr and carry on.", 
            "title": "Constructor arguments"
        }, 
        {
            "location": "/autonym-responder/#what-the-middleware-does-with-the-response", 
            "text": "If an error occurred, the error handler function will be passed the error. If there was no error handler function\nprovided, it will pass the error to the next middleware.  If the response is not already sent, then AutonymResponder will:   Check for a property named  data  on the response object.  If it exists and is not null, it will send the response, with a JSON body set to the value of  res.data .  If  res.data  is null, it will send the response with no body.    Otherwise, it will return a 404 error.", 
            "title": "What the middleware does with the response"
        }, 
        {
            "location": "/autonym-responder/#autonymresponder-api", 
            "text": "", 
            "title": "AutonymResponder API"
        }, 
        {
            "location": "/autonym-responder/#constructorhandleerror", 
            "text": "Creates a new instance of AutonymResponder, optionally taking a function to handle errors.", 
            "title": "#constructor(handleError)"
        }, 
        {
            "location": "/autonym-responder/#handleerror", 
            "text": "The function supplied to the constructor, or  undefined . Can be changed at runtime.", 
            "title": "#handleError"
        }, 
        {
            "location": "/autonym-responder/#middleware", 
            "text": "Express middleware that can be mounted to your application to send the response and capture errors.", 
            "title": "#middleware"
        }, 
        {
            "location": "/model/", 
            "text": "Model\n\n\nAutonym requests resolve to create, read, update, and delete actions against a model specified in the route. Autonym\ntakes a model class and generates a thin controller on top of it, which manages HTTP requests and automates common tasks\nlike validation and routing.\n\n\nDeveloper-defined models in Autonym extend from the abstract \nModel\n class, which is exported from the library. If the\nmodel class defines properties and methods with certain names, then Autonym will use them when actions are requested.\n\n\nAutonym model classes have only static methods and are never instantiated.\n\n\nImplementation API\n\n\n.models\n\n\nA static property that is already set by Autonym. It has references to the other models so that you can call methods on\nother models within this model's functions, e.g. \nthis.models.Animal.findOne('123').then(...)\n.\n\n\n.route\n\n\nA static property called \nroute\n can be used to define the part of the URL path that is the root for CRUD actions\nagainst this model. For example:\n\n\nclass Person extends Model {}\nPerson.route = 'persons';\n\nexport default Person;\n\n\n\n\nAutonym will define routes like \n/persons/\n and \n/persons/:id\n that will map to this model's actions. Note that this\nproperty must be unique per model, or the first model defined with the given route will override any others.\n\n\nIf this property is not set, it defaults to \"pluralizing\" the model's name using the\n\ninflection\n library, so in the previous example, the default value is\n\npeople\n.\n\n\n._init()\n\n\nIf the class has a static method named \n_init\n, it will be called by Autonym when the app is starting up. This function\nis only called once on the model. A common use case is to establish a connection with a database. If this method returns\na promise, then the app will not be considered \"ready\" until the promise resolves.\n\n\n._implementDefaultStoreCrudMethods\u200b(store, methods)\n\n\nUnlike the other methods in this section, this is inherited from the abstract Model class. This method can be called in\n\n_init\n.\n\n\nCopies methods on the store object onto the class. Copies the given methods, or defaults to copying \nfind\n, \nfindOne\n,\n\ncreate\n, \nfindOneAndUpdate\n, \nfindOneAndDelete\n, \nserialize\n, and \nunserialize\n. It will not copy the method if it does\nnot exist on the store, and it will not copy any methods explicitly defined on the class already (e.g. it will not\noverwrite \n_find\n if it is already defined).\n\n\n._create(attributes)\n\n\nIf the class has a static method named \n_create\n, it will be called by Autonym during a POST request to \n/:modelRoute\n\nafter all validation has passed. It accepts a parameter \nattributes\n, which is all the attributes to add to the new\nresource. This object has been filtered by the JSON schema. It has also been passed through the \nserialize\n function\n(see \n_serialize\n in this section).\n\n\nThis method \nmust\n return a promise. If the promise resolves, it must return an object that is the complete\nrepresentation of the resource, which will be passed to \nunserialize\n (see \n_unserialize\n in this section). It can also\nreject with an error. If the error was client-caused, it should reject with a subclass of\n\nautonym-client-errors.ClientError\n.\n\n\nIf this method is not set, then the client will receive a 405 method not allowed error.\n\n\n._find(query, filter)\n\n\nIf the class has a static method named \n_find\n, it will be called by Autonym during a GET request to \n/:modelRoute\n\nafter all validation has passed. It accepts an object \nquery\n, which is simply the query string parameters for\nsearching, sorting, and paginating. It is also passed a \nfilter\n object, which contains an array of \"filters,\" which can\nbe added by policies. Neither of these objects has a set definition; the query is everything from the query string and\nthe filter is an array containing anything that was added by policies.\n\n\nThis method \nmust\n return a promise. If the promise resolves, it must return an array of resources, each of which will\nbe passed to \nunserialize\n (see \n_unserialize\n in this section). It can also reject with an error. If the error was\nclient-caused, it should reject with a subclass of \nautonym-client-errors.ClientError\n.\n\n\nIf this method is not set, then the client will receive a 405 method not allowed error.\n\n\n._findOne(resourceId, filter)\n\n\nIf the class has a static method named \n_findOne\n, it will be called by Autonym during a GET request to\n\n/:modelRoute/:resourceId\n after all validation has passed. It accepts a parameter \nresourceId\n, which is the id of the\nresource to fetch. It is also passed a \nfilter\n object, which contains an array of \"filters,\" which can be added by\npolicies.\n\n\nThis method \nmust\n return a promise. If the promise resolves, it must return an object that is the complete\nrepresentation of the resource, which will be passed to \nunserialize\n (see \n_unserialize\n in this section). It can also\nreject with an error. If the error was client-caused, it should reject with a subclass of\n\nautonym-client-errors.ClientError\n.\n\n\nIf this method is not set, then the client will receive a 405 method not allowed error. \nNote:\n This method is a\nprerequisite for \n_findOneAndUpdate\n, which will not work if this function is not defined.\n\n\n._findOneAndUpdate(resourceId, attributes, filter, completeResource)\n\n\nIf the class has a static method named \n_findOneAndUpdate\n, it will be called by Autonym during a PATCH or PUT request\nto \n/:modelRoute/:resourceId\n after all validation has passed. It accepts a parameter \nresourceId\n, which is the id of\nthe resource to fetch. It accepts a second parameter \nattributes\n, which is all the attributes to be updated. This\nobject has been filtered by the JSON schema. It has also been passed through the \nserialize\n function (see \n_serialize\n\nin this section). Third, it is passed a \nfilter\n object, which contains an array of \"filters,\" which can be added by\npolicies. Finally, it accepts the \ncompleteResource\n, which is the changed attributes merged with the results of\n\n_findOne()\n.\n\n\nThis method \nmust\n return a promise. If the promise resolves, it must return an object that is the complete\nrepresentation of the resource, which will be passed to \nunserialize\n (see \n_unserialize\n in this section). It can also\nreject with an error. If the error was client-caused, it should reject with a subclass of\n\nautonym-client-errors.ClientError\n.\n\n\nIf this method is not set, then the client will receive a 405 method not allowed error.\n\n\n._findOneAndDelete(resourceId, filter)\n\n\nIf the class has a static method named \n_findOneAndDelete\n, it will be called by Autonym during a DELETE request to\n\n/:modelRoute/:resourceId\n after all validation has passed. It accepts a parameter \nresourceId\n, which is the id of the\nresource to delete. It is also passed a \nfilter\n object, which contains an array of \"filters,\" which can be added by\npolicies.\n\n\nThis method \nmust\n return a promise. If the promise resolves, the client will be sent no content. It can also reject\nwith an error. If the error was client-caused, it should reject with a subclass of \nautonym-client-errors.ClientError\n.\n\n\nIf this method is not set, then the client will receive a 405 method not allowed error.\n\n\n._serialize(attributes)\n\n\nIf the class has a static method named \n_serialize\n, it will be called by Autonym for create and update actions after\nall validation is passed. It is a convenience method that should return a new object that will be passed to the\n\n_create\n and \n_findOneAndUpdate\n functions. A common use case for this function is to map fields on the request object\nto column names. It must return a new object.\n\n\n._unserialize(attributes)\n\n\nIf the class has a static method named \n_unserialize\n, it will be called by Autonym for all actions that return\nresources to the client after successful operations. It is a convenience method that should return a new object that\nwill be sent to the client. A common use case for this function is to map column names from a database to model\nattributes. It must return a new object.\n\n\n._preValidateAgainstSchema(req)\n\n\nIf the class has a static method named \n_preValidateAgainstSchema\n, it will be called by Autonym \nbefore\n validation\nagainst the JSON schema is performed. This method is called for operations that create a new resource or update an\nexisting resource and therefore have a body to validate. \nIt is called even if the model has no schema.\n A common use\ncase is to add a computed property to the body of the request. It can return a promise for asynchronous operations. It\nis passed the \nreq\n object.\n\n\n._postValidateAgainstSchema(req)\n\n\nIf the class has a static method named \n_postValidateAgainstSchema\n, it will be called by Autonym \nafter\n validation\nagainst the JSON schema is performed. This method is called for operations that create a new resource or update an\nexisting resource and therefore have a body to validate. \nIt is called even if the model has no schema.\n Generally\npost-schema validation should be handled by policies instead of this hook. It can return a promise for asynchronous\noperations. It is passed the \nreq\n object.\n\n\n._preValidateAgainstPolicies(req)\n\n\nIf the class has a static method named \n_preValidateAgainstPolicies\n, it will be called by Autonym \nbefore\n validation\nagainst policies is performed. This method is called for any operation. (For create and update operations, it is called\nafter schema validation and hooks.) \nIt is called even if the operation has no corresponding policies.\n It can return a\npromise for asynchronous operations. It is passed the \nreq\n object.\n\n\n._postValidateAgainstPolicies(req)\n\n\nIf the class has a static method named \n_postValidateAgainstPolicies\n, it will be called by Autonym \nafter\n validation\nagainst policies is performed. This method is called for any operation. \nIt is called even if the operation has no\ncorresponding policies.\n It can return a promise for asynchronous operations. It is passed the \nreq\n object.\n\n\nPublic API\n\n\nThe model inherits from the abstract Model class, which has a number of methods on it which can be called in your code\nwhen you want to interact with a model programmatically.\n\n\n.validate(req)\n\n\nThis function performs schema and policy validation, given a request, and returns a promise that resolves or rejects\nwith an error.\n\n\n.doSchemaValidation(req)\n\n\nThis function performs schema validation, given a request, along with the pre- and post-hooks if they are defined. It\nreturns a promise that resolves or rejects with an error. For create and update actions, it adds a \ndata\n property on\nthe request object. For update actions, it also adds a \ncompleteResource\n object, which represents the full resource\n(contrasted to \ndata\n, which is only the attributes the user specified in the request).\n\n\n.doPolicyValidation(req)\n\n\nThis function performs policy validation, given a request, along with pre- and post-hooks if they are defined. It\nreturns a promise that resolves or rejects with an error.\n\n\n.create(body, filter)\n\n\nCalls \n_create\n with the serialized body and filter and returns the promise after unserializing the result, or rejects\nwith a method not implemented error.\n\n\n.find(query, filter)\n\n\nCalls \n_find\n with given query and filter and returns the promise after unserializing the results, or rejects with a\nmethod not implemented error.\n\n\n.findOne(resourceId, filter)\n\n\nCalls \n_findOne\n with the id and filter and returns the promise after unserializing the result, or rejects with a method\nnot implemented error.\n\n\n.findOneAndUpdate(resourceId, body, filter, completeResource)\n\n\nCalls \n_findOneAndUpdate\n with the id, serialized body, and filter and returns the promise after unserializing the\nresult, or rejects with a method not implemented error.\n\n\n.findOneAndDelete(resourceId, filter)\n\n\nCalls \n_findOneAndDelete\n with the id and filter and returns the promise, or rejects with a method not implemented\nerror.\n\n\n.serialize(attributes)\n\n\nClones the given attributes and passes them to \n_serialize\n (if defined) before returning the result.\n\n\n.unserialize(attributes)\n\n\nClones the given attributes and passes them to \n_unserialize\n (if defined) before returning the result.\n\n\n.evaluatePolicies(expression, req)\n\n\nEvaluates the given asynchronous boolean expression against the request. Returns a promise that resolves or rejects with\na policy error.\n\n\nIn-memory model example\n\n\nThis is an example of a model that simply stores person objects in memory.\n\n\nimport {Model} from 'autonym';\nimport {NotFoundError} from 'autonym-client-errors';\n\nclass Todo extends Model {\n  static _create (attributes) {\n    const id = ++Todo._counter;\n    const todo = {...attributes, id};\n    Todo._todos.push(todo);\n    Todo._todosById[id] = todo;\n    return Promise.resolve(todo);\n  }\n\n  static _find (query) {\n    return Promise.resolve(Todo._todos);\n  }\n\n  static _findOne (id) {\n    const todo = Todo._todosById[id];\n    if (todo) {\n      return Promise.resolve(todo);\n    } else {\n      return Promise.reject(new NotFoundError('No resource found that meets the given criteria.'));\n    }\n  }\n\n  static _findOneAndUpdate (id, attributes) {\n    const todo = Todo._todosById[id];\n    if (todo) {\n      return Promise.resolve(Object.assign(todo, attributes));\n    } else {\n      return Promise.reject(new NotFoundError('No resource found that meets the given criteria.'));\n    }\n  }\n\n  static _findOneAndDelete (id) {\n    const todo = Todo._todosById[id];\n    const index = Todo._todos.indexOf(todo);\n    if (index \n -1) {\n      Todo._todos.splice(index, 1);\n      delete Todo._todosById[id];\n      return Promise.resolve(null);\n    } else {\n      return Promise.reject(new NotFoundError('No resource found that meets the given criteria.'));\n    }\n  }\n}\n\nTodo._todos = [];\nTodo._todosById = {};\nTodo._counter = 0;\n\nexport default Todo;", 
            "title": "Model"
        }, 
        {
            "location": "/model/#model", 
            "text": "Autonym requests resolve to create, read, update, and delete actions against a model specified in the route. Autonym\ntakes a model class and generates a thin controller on top of it, which manages HTTP requests and automates common tasks\nlike validation and routing.  Developer-defined models in Autonym extend from the abstract  Model  class, which is exported from the library. If the\nmodel class defines properties and methods with certain names, then Autonym will use them when actions are requested.  Autonym model classes have only static methods and are never instantiated.", 
            "title": "Model"
        }, 
        {
            "location": "/model/#implementation-api", 
            "text": "", 
            "title": "Implementation API"
        }, 
        {
            "location": "/model/#models", 
            "text": "A static property that is already set by Autonym. It has references to the other models so that you can call methods on\nother models within this model's functions, e.g.  this.models.Animal.findOne('123').then(...) .", 
            "title": ".models"
        }, 
        {
            "location": "/model/#route", 
            "text": "A static property called  route  can be used to define the part of the URL path that is the root for CRUD actions\nagainst this model. For example:  class Person extends Model {}\nPerson.route = 'persons';\n\nexport default Person;  Autonym will define routes like  /persons/  and  /persons/:id  that will map to this model's actions. Note that this\nproperty must be unique per model, or the first model defined with the given route will override any others.  If this property is not set, it defaults to \"pluralizing\" the model's name using the inflection  library, so in the previous example, the default value is people .", 
            "title": ".route"
        }, 
        {
            "location": "/model/#_init", 
            "text": "If the class has a static method named  _init , it will be called by Autonym when the app is starting up. This function\nis only called once on the model. A common use case is to establish a connection with a database. If this method returns\na promise, then the app will not be considered \"ready\" until the promise resolves.", 
            "title": "._init()"
        }, 
        {
            "location": "/model/#_implementdefaultstorecrudmethodsstore-methods", 
            "text": "Unlike the other methods in this section, this is inherited from the abstract Model class. This method can be called in _init .  Copies methods on the store object onto the class. Copies the given methods, or defaults to copying  find ,  findOne , create ,  findOneAndUpdate ,  findOneAndDelete ,  serialize , and  unserialize . It will not copy the method if it does\nnot exist on the store, and it will not copy any methods explicitly defined on the class already (e.g. it will not\noverwrite  _find  if it is already defined).", 
            "title": "._implementDefaultStoreCrudMethods\u200b(store, methods)"
        }, 
        {
            "location": "/model/#_createattributes", 
            "text": "If the class has a static method named  _create , it will be called by Autonym during a POST request to  /:modelRoute \nafter all validation has passed. It accepts a parameter  attributes , which is all the attributes to add to the new\nresource. This object has been filtered by the JSON schema. It has also been passed through the  serialize  function\n(see  _serialize  in this section).  This method  must  return a promise. If the promise resolves, it must return an object that is the complete\nrepresentation of the resource, which will be passed to  unserialize  (see  _unserialize  in this section). It can also\nreject with an error. If the error was client-caused, it should reject with a subclass of autonym-client-errors.ClientError .  If this method is not set, then the client will receive a 405 method not allowed error.", 
            "title": "._create(attributes)"
        }, 
        {
            "location": "/model/#_findquery-filter", 
            "text": "If the class has a static method named  _find , it will be called by Autonym during a GET request to  /:modelRoute \nafter all validation has passed. It accepts an object  query , which is simply the query string parameters for\nsearching, sorting, and paginating. It is also passed a  filter  object, which contains an array of \"filters,\" which can\nbe added by policies. Neither of these objects has a set definition; the query is everything from the query string and\nthe filter is an array containing anything that was added by policies.  This method  must  return a promise. If the promise resolves, it must return an array of resources, each of which will\nbe passed to  unserialize  (see  _unserialize  in this section). It can also reject with an error. If the error was\nclient-caused, it should reject with a subclass of  autonym-client-errors.ClientError .  If this method is not set, then the client will receive a 405 method not allowed error.", 
            "title": "._find(query, filter)"
        }, 
        {
            "location": "/model/#_findoneresourceid-filter", 
            "text": "If the class has a static method named  _findOne , it will be called by Autonym during a GET request to /:modelRoute/:resourceId  after all validation has passed. It accepts a parameter  resourceId , which is the id of the\nresource to fetch. It is also passed a  filter  object, which contains an array of \"filters,\" which can be added by\npolicies.  This method  must  return a promise. If the promise resolves, it must return an object that is the complete\nrepresentation of the resource, which will be passed to  unserialize  (see  _unserialize  in this section). It can also\nreject with an error. If the error was client-caused, it should reject with a subclass of autonym-client-errors.ClientError .  If this method is not set, then the client will receive a 405 method not allowed error.  Note:  This method is a\nprerequisite for  _findOneAndUpdate , which will not work if this function is not defined.", 
            "title": "._findOne(resourceId, filter)"
        }, 
        {
            "location": "/model/#_findoneandupdateresourceid-attributes-filter-completeresource", 
            "text": "If the class has a static method named  _findOneAndUpdate , it will be called by Autonym during a PATCH or PUT request\nto  /:modelRoute/:resourceId  after all validation has passed. It accepts a parameter  resourceId , which is the id of\nthe resource to fetch. It accepts a second parameter  attributes , which is all the attributes to be updated. This\nobject has been filtered by the JSON schema. It has also been passed through the  serialize  function (see  _serialize \nin this section). Third, it is passed a  filter  object, which contains an array of \"filters,\" which can be added by\npolicies. Finally, it accepts the  completeResource , which is the changed attributes merged with the results of _findOne() .  This method  must  return a promise. If the promise resolves, it must return an object that is the complete\nrepresentation of the resource, which will be passed to  unserialize  (see  _unserialize  in this section). It can also\nreject with an error. If the error was client-caused, it should reject with a subclass of autonym-client-errors.ClientError .  If this method is not set, then the client will receive a 405 method not allowed error.", 
            "title": "._findOneAndUpdate(resourceId, attributes, filter, completeResource)"
        }, 
        {
            "location": "/model/#_findoneanddeleteresourceid-filter", 
            "text": "If the class has a static method named  _findOneAndDelete , it will be called by Autonym during a DELETE request to /:modelRoute/:resourceId  after all validation has passed. It accepts a parameter  resourceId , which is the id of the\nresource to delete. It is also passed a  filter  object, which contains an array of \"filters,\" which can be added by\npolicies.  This method  must  return a promise. If the promise resolves, the client will be sent no content. It can also reject\nwith an error. If the error was client-caused, it should reject with a subclass of  autonym-client-errors.ClientError .  If this method is not set, then the client will receive a 405 method not allowed error.", 
            "title": "._findOneAndDelete(resourceId, filter)"
        }, 
        {
            "location": "/model/#_serializeattributes", 
            "text": "If the class has a static method named  _serialize , it will be called by Autonym for create and update actions after\nall validation is passed. It is a convenience method that should return a new object that will be passed to the _create  and  _findOneAndUpdate  functions. A common use case for this function is to map fields on the request object\nto column names. It must return a new object.", 
            "title": "._serialize(attributes)"
        }, 
        {
            "location": "/model/#_unserializeattributes", 
            "text": "If the class has a static method named  _unserialize , it will be called by Autonym for all actions that return\nresources to the client after successful operations. It is a convenience method that should return a new object that\nwill be sent to the client. A common use case for this function is to map column names from a database to model\nattributes. It must return a new object.", 
            "title": "._unserialize(attributes)"
        }, 
        {
            "location": "/model/#_prevalidateagainstschemareq", 
            "text": "If the class has a static method named  _preValidateAgainstSchema , it will be called by Autonym  before  validation\nagainst the JSON schema is performed. This method is called for operations that create a new resource or update an\nexisting resource and therefore have a body to validate.  It is called even if the model has no schema.  A common use\ncase is to add a computed property to the body of the request. It can return a promise for asynchronous operations. It\nis passed the  req  object.", 
            "title": "._preValidateAgainstSchema(req)"
        }, 
        {
            "location": "/model/#_postvalidateagainstschemareq", 
            "text": "If the class has a static method named  _postValidateAgainstSchema , it will be called by Autonym  after  validation\nagainst the JSON schema is performed. This method is called for operations that create a new resource or update an\nexisting resource and therefore have a body to validate.  It is called even if the model has no schema.  Generally\npost-schema validation should be handled by policies instead of this hook. It can return a promise for asynchronous\noperations. It is passed the  req  object.", 
            "title": "._postValidateAgainstSchema(req)"
        }, 
        {
            "location": "/model/#_prevalidateagainstpoliciesreq", 
            "text": "If the class has a static method named  _preValidateAgainstPolicies , it will be called by Autonym  before  validation\nagainst policies is performed. This method is called for any operation. (For create and update operations, it is called\nafter schema validation and hooks.)  It is called even if the operation has no corresponding policies.  It can return a\npromise for asynchronous operations. It is passed the  req  object.", 
            "title": "._preValidateAgainstPolicies(req)"
        }, 
        {
            "location": "/model/#_postvalidateagainstpoliciesreq", 
            "text": "If the class has a static method named  _postValidateAgainstPolicies , it will be called by Autonym  after  validation\nagainst policies is performed. This method is called for any operation.  It is called even if the operation has no\ncorresponding policies.  It can return a promise for asynchronous operations. It is passed the  req  object.", 
            "title": "._postValidateAgainstPolicies(req)"
        }, 
        {
            "location": "/model/#public-api", 
            "text": "The model inherits from the abstract Model class, which has a number of methods on it which can be called in your code\nwhen you want to interact with a model programmatically.", 
            "title": "Public API"
        }, 
        {
            "location": "/model/#validatereq", 
            "text": "This function performs schema and policy validation, given a request, and returns a promise that resolves or rejects\nwith an error.", 
            "title": ".validate(req)"
        }, 
        {
            "location": "/model/#doschemavalidationreq", 
            "text": "This function performs schema validation, given a request, along with the pre- and post-hooks if they are defined. It\nreturns a promise that resolves or rejects with an error. For create and update actions, it adds a  data  property on\nthe request object. For update actions, it also adds a  completeResource  object, which represents the full resource\n(contrasted to  data , which is only the attributes the user specified in the request).", 
            "title": ".doSchemaValidation(req)"
        }, 
        {
            "location": "/model/#dopolicyvalidationreq", 
            "text": "This function performs policy validation, given a request, along with pre- and post-hooks if they are defined. It\nreturns a promise that resolves or rejects with an error.", 
            "title": ".doPolicyValidation(req)"
        }, 
        {
            "location": "/model/#createbody-filter", 
            "text": "Calls  _create  with the serialized body and filter and returns the promise after unserializing the result, or rejects\nwith a method not implemented error.", 
            "title": ".create(body, filter)"
        }, 
        {
            "location": "/model/#findquery-filter", 
            "text": "Calls  _find  with given query and filter and returns the promise after unserializing the results, or rejects with a\nmethod not implemented error.", 
            "title": ".find(query, filter)"
        }, 
        {
            "location": "/model/#findoneresourceid-filter", 
            "text": "Calls  _findOne  with the id and filter and returns the promise after unserializing the result, or rejects with a method\nnot implemented error.", 
            "title": ".findOne(resourceId, filter)"
        }, 
        {
            "location": "/model/#findoneandupdateresourceid-body-filter-completeresource", 
            "text": "Calls  _findOneAndUpdate  with the id, serialized body, and filter and returns the promise after unserializing the\nresult, or rejects with a method not implemented error.", 
            "title": ".findOneAndUpdate(resourceId, body, filter, completeResource)"
        }, 
        {
            "location": "/model/#findoneanddeleteresourceid-filter", 
            "text": "Calls  _findOneAndDelete  with the id and filter and returns the promise, or rejects with a method not implemented\nerror.", 
            "title": ".findOneAndDelete(resourceId, filter)"
        }, 
        {
            "location": "/model/#serializeattributes", 
            "text": "Clones the given attributes and passes them to  _serialize  (if defined) before returning the result.", 
            "title": ".serialize(attributes)"
        }, 
        {
            "location": "/model/#unserializeattributes", 
            "text": "Clones the given attributes and passes them to  _unserialize  (if defined) before returning the result.", 
            "title": ".unserialize(attributes)"
        }, 
        {
            "location": "/model/#evaluatepoliciesexpression-req", 
            "text": "Evaluates the given asynchronous boolean expression against the request. Returns a promise that resolves or rejects with\na policy error.", 
            "title": ".evaluatePolicies(expression, req)"
        }, 
        {
            "location": "/model/#in-memory-model-example", 
            "text": "This is an example of a model that simply stores person objects in memory.  import {Model} from 'autonym';\nimport {NotFoundError} from 'autonym-client-errors';\n\nclass Todo extends Model {\n  static _create (attributes) {\n    const id = ++Todo._counter;\n    const todo = {...attributes, id};\n    Todo._todos.push(todo);\n    Todo._todosById[id] = todo;\n    return Promise.resolve(todo);\n  }\n\n  static _find (query) {\n    return Promise.resolve(Todo._todos);\n  }\n\n  static _findOne (id) {\n    const todo = Todo._todosById[id];\n    if (todo) {\n      return Promise.resolve(todo);\n    } else {\n      return Promise.reject(new NotFoundError('No resource found that meets the given criteria.'));\n    }\n  }\n\n  static _findOneAndUpdate (id, attributes) {\n    const todo = Todo._todosById[id];\n    if (todo) {\n      return Promise.resolve(Object.assign(todo, attributes));\n    } else {\n      return Promise.reject(new NotFoundError('No resource found that meets the given criteria.'));\n    }\n  }\n\n  static _findOneAndDelete (id) {\n    const todo = Todo._todosById[id];\n    const index = Todo._todos.indexOf(todo);\n    if (index   -1) {\n      Todo._todos.splice(index, 1);\n      delete Todo._todosById[id];\n      return Promise.resolve(null);\n    } else {\n      return Promise.reject(new NotFoundError('No resource found that meets the given criteria.'));\n    }\n  }\n}\n\nTodo._todos = [];\nTodo._todosById = {};\nTodo._counter = 0;\n\nexport default Todo;", 
            "title": "In-memory model example"
        }, 
        {
            "location": "/client-errors/", 
            "text": "Client Errors\n\n\nAt various stages in the request/response life cycle, errors can arise. Generally there are two types of errors in an\nAPI application: those that occur at the server level (connection errors, timeouts, runtime errors, and so on), called\n\"internal server errors,\" and those that are caused by a problem with the request (unauthenticated, forbidden, malformed\npayloads, etc.), called \"client errors.\" We distinguish these because, typically, the details of internal server errors\nare significant to the systems administrators and developers and should be hidden from the client, while client errors\nare often unimportant to the ops team and critical to the API's consumer.\n\n\nAutonym considers any error to fall into the internal server error category, unless it is explicitly an instance of a\nspecial class called ClientError. The ClientError class and its subclasses are exported by a module called\n\nautonym-client-errors\n. JSON schema validation already throws instances of ClientError, but custom policies or model\nmethods that need to throw errors that should be seen by the client should wrap their errors in a subclass of\nClientError or the client will just receive a 500 error.\n\n\nUsage\n\n\nClient errors are included in the \nautonym-client-errors\n package and are named exports. Just import the error class you\nintend to use, instantiate it according to the API, and throw it in a model method, store, or policy.\n\n\nimport {UnauthorizedError} from 'autonym-client-errors';\n\nfunction isLoggedIn (req) {\n  if (!req.isLoggedIn) {\n    throw new UnauthorizedError('You are not logged in.');\n  }\n}\n\nexport default isLoggedIn;\n\n\n\n\nWhen checking to see if an error object is a derivative of ClientError, \nerr instanceof ClientError\n is \nnot\n the best\nsolution. Third-party packages that depend on \nautonym-client-errors\n may have its own copy of the module, meaning that\nthe ClientError class is a different reference. To solve this issue, another package named \ninstance-of-name\n will check\nto see if the error is derived from a class with a certain name instead of resolving to the exact reference.\n\n\nimport instanceOf from 'instance-of-name';\n\nfunction handleError (err) {\n  if (!instanceOf(err, 'ClientError') {\n    // An internal server error occurred\n    setImmediate(() =\n { throw err; });\n  }\n}\n\nexport default handleError;\n\n\n\n\nAPI\n\n\nClientError(status, message)\n\n\nClientError has subclasses that describe specific error cases. Typically ClientError is not instantiated directly. It is\ninstantiated with a status code and message describing the nature of the error, which can be of any JSON-serializable\ntype.\n\n\nBadRequestError(message)\n\n\nBadRequest errors return 400 status codes and include a message describing what was wrong with the request.\n\n\nForbiddenError(message)\n\n\nForbidden errors return 403 status codes and include a message describing why the user was not allowed to perform the\nrequest.\n\n\nInvalidPayloadError(ajvErrors)\n\n\nInvalidPayload errors are used directly by the JSON schema validator. They are subclassed from BadRequest and return\nan error message in a specific format that's designed to be parseable by the client to determine which field(s) were\nsent incorrectly.\n\n\nMethodNotAllowedError(message)\n\n\nMethodNotAllowed errors return 405 status codes and include a message describing that the request method does not apply\nto the given resource type. These are used directly by Autonym if a request is made for a model that does not implement\nthat method, e.g. if a DELETE request is made to a resource whose model does not implement a \n_findOneAndDelete\n method.\n\n\nNotFoundError(message)\n\n\nNotFound errors return 404 status codes and include a message describing that the requested resource was not found.\nThese are used directly by Autonym if a request is made to get, update, or delete a nonexistent resource, or to make any\nrequest against a nonexistent model.\n\n\nUnauthorizedError(message)\n\n\nUnauthorized errors return 401 status codes and include a message describing that the user was not authorized to\nperform the request.", 
            "title": "Client Errors"
        }, 
        {
            "location": "/client-errors/#client-errors", 
            "text": "At various stages in the request/response life cycle, errors can arise. Generally there are two types of errors in an\nAPI application: those that occur at the server level (connection errors, timeouts, runtime errors, and so on), called\n\"internal server errors,\" and those that are caused by a problem with the request (unauthenticated, forbidden, malformed\npayloads, etc.), called \"client errors.\" We distinguish these because, typically, the details of internal server errors\nare significant to the systems administrators and developers and should be hidden from the client, while client errors\nare often unimportant to the ops team and critical to the API's consumer.  Autonym considers any error to fall into the internal server error category, unless it is explicitly an instance of a\nspecial class called ClientError. The ClientError class and its subclasses are exported by a module called autonym-client-errors . JSON schema validation already throws instances of ClientError, but custom policies or model\nmethods that need to throw errors that should be seen by the client should wrap their errors in a subclass of\nClientError or the client will just receive a 500 error.", 
            "title": "Client Errors"
        }, 
        {
            "location": "/client-errors/#usage", 
            "text": "Client errors are included in the  autonym-client-errors  package and are named exports. Just import the error class you\nintend to use, instantiate it according to the API, and throw it in a model method, store, or policy.  import {UnauthorizedError} from 'autonym-client-errors';\n\nfunction isLoggedIn (req) {\n  if (!req.isLoggedIn) {\n    throw new UnauthorizedError('You are not logged in.');\n  }\n}\n\nexport default isLoggedIn;  When checking to see if an error object is a derivative of ClientError,  err instanceof ClientError  is  not  the best\nsolution. Third-party packages that depend on  autonym-client-errors  may have its own copy of the module, meaning that\nthe ClientError class is a different reference. To solve this issue, another package named  instance-of-name  will check\nto see if the error is derived from a class with a certain name instead of resolving to the exact reference.  import instanceOf from 'instance-of-name';\n\nfunction handleError (err) {\n  if (!instanceOf(err, 'ClientError') {\n    // An internal server error occurred\n    setImmediate(() =  { throw err; });\n  }\n}\n\nexport default handleError;", 
            "title": "Usage"
        }, 
        {
            "location": "/client-errors/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/client-errors/#clienterrorstatus-message", 
            "text": "ClientError has subclasses that describe specific error cases. Typically ClientError is not instantiated directly. It is\ninstantiated with a status code and message describing the nature of the error, which can be of any JSON-serializable\ntype.", 
            "title": "ClientError(status, message)"
        }, 
        {
            "location": "/client-errors/#badrequesterrormessage", 
            "text": "BadRequest errors return 400 status codes and include a message describing what was wrong with the request.", 
            "title": "BadRequestError(message)"
        }, 
        {
            "location": "/client-errors/#forbiddenerrormessage", 
            "text": "Forbidden errors return 403 status codes and include a message describing why the user was not allowed to perform the\nrequest.", 
            "title": "ForbiddenError(message)"
        }, 
        {
            "location": "/client-errors/#invalidpayloaderrorajverrors", 
            "text": "InvalidPayload errors are used directly by the JSON schema validator. They are subclassed from BadRequest and return\nan error message in a specific format that's designed to be parseable by the client to determine which field(s) were\nsent incorrectly.", 
            "title": "InvalidPayloadError(ajvErrors)"
        }, 
        {
            "location": "/client-errors/#methodnotallowederrormessage", 
            "text": "MethodNotAllowed errors return 405 status codes and include a message describing that the request method does not apply\nto the given resource type. These are used directly by Autonym if a request is made for a model that does not implement\nthat method, e.g. if a DELETE request is made to a resource whose model does not implement a  _findOneAndDelete  method.", 
            "title": "MethodNotAllowedError(message)"
        }, 
        {
            "location": "/client-errors/#notfounderrormessage", 
            "text": "NotFound errors return 404 status codes and include a message describing that the requested resource was not found.\nThese are used directly by Autonym if a request is made to get, update, or delete a nonexistent resource, or to make any\nrequest against a nonexistent model.", 
            "title": "NotFoundError(message)"
        }, 
        {
            "location": "/client-errors/#unauthorizederrormessage", 
            "text": "Unauthorized errors return 401 status codes and include a message describing that the user was not authorized to\nperform the request.", 
            "title": "UnauthorizedError(message)"
        }, 
        {
            "location": "/creating-a-store/", 
            "text": "Creating a Store\n\n\nStores are a way of separating specific code for persisting data from models to make it more reusable and keep it from\ncluttering your business logic.\n\n\nStores define a lot of the same methods as models, so they're easy to implement if you have built a model. A model that\nuses a store can instantiate it in the \n_init\n method and then clone the methods from the store onto the model if they\nare named the same by using \n_implementDefaultStoreCrudMethods\u200b\n.\n\n\nLike model methods, stores should depend on \nautonym-client-errors\n and throw subclasses of ClientError when applicable.\n\n\nStores can define any methods they want, but if they implement the methods defined in the list below, they can be\nautomatically copied to the model that uses the store, which reduces the amount of scaffolding developers need to get it\nup and running.\n\n\nThe methods in this list can be automatically copied to models that are using the store. They have identical\nsignatures to the methods described in the \nModel Implementation API\n, but they are\nnot prefixed with an \n_\n like the model methods.\n\n\nMethods\n\n\n\n\n#find(query, filter)\n\n\n#findOne(resourceId, filter)\n\n\n#create(attributes)\n\n\n#findOneAndUpdate(resourceId, attributes, filter, completeResource)\n\n\n#findOneAndDelete(resourceId, filter)\n\n\n#serialize(attributes)\n\n\n#unserialize(attributes)\n\n\n\n\nExample\n\n\nThis is a simple example of an in-memory store implementation and usage.\n\n\nStore\n\n\nimport {NotFoundError} from 'autonym-client-errors';\n\nclass InMemoryStore {\n  constructor () {\n    this._records = [];\n    this._recordsById = {};\n    this._counter = 0;\n  }\n\n  create (attributes) {\n    const id = ++this._counter;\n    const record = {...attributes, id};\n    this._records.push(record);\n    this._recordsById[id] = record;\n    return Promise.resolve(record);\n  }\n\n  find (query) {\n    return Promise.resolve(this._records);\n  }\n\n  findOne (id) {\n    const record = this._recordsById[id];\n    if (record) {\n      return Promise.resolve(record);\n    } else {\n      return Promise.reject(new NotFoundError('No resource found that meets the given criteria.'));\n    }\n  }\n\n  findOneAndUpdate (id, attributes) {\n    const record = this._recordsById[id];\n    if (record) {\n      return Promise.resolve(Object.assign(record, attributes));\n    } else {\n      return Promise.reject(new NotFoundError('No resource found that meets the given criteria.'));\n    }\n  }\n\n  findOneAndDelete (id) {\n    const record = this._recordsById[id];\n    const index = this._records.indexOf(record);\n    if (index \n -1) {\n      this._records.splice(index, 1);\n      delete this._recordsById[id];\n      return Promise.resolve(null);\n    } else {\n      return Promise.reject(new NotFoundError('No resource found that meets the given criteria.'));\n    }\n  }\n}\n\nexport default InMemoryStore;\n\n\n\n\nModel\n\n\nimport {Model} from 'autonym';\nimport InMemoryStore from '../stores/in-memory.store';\n\nclass Person extends Model {\n  static _init () {\n    super._implementDefaultStoreCrudMethods(new InMemoryStore());\n  }\n}\n\nexport default Person;", 
            "title": "Creating a Store"
        }, 
        {
            "location": "/creating-a-store/#creating-a-store", 
            "text": "Stores are a way of separating specific code for persisting data from models to make it more reusable and keep it from\ncluttering your business logic.  Stores define a lot of the same methods as models, so they're easy to implement if you have built a model. A model that\nuses a store can instantiate it in the  _init  method and then clone the methods from the store onto the model if they\nare named the same by using  _implementDefaultStoreCrudMethods\u200b .  Like model methods, stores should depend on  autonym-client-errors  and throw subclasses of ClientError when applicable.  Stores can define any methods they want, but if they implement the methods defined in the list below, they can be\nautomatically copied to the model that uses the store, which reduces the amount of scaffolding developers need to get it\nup and running.  The methods in this list can be automatically copied to models that are using the store. They have identical\nsignatures to the methods described in the  Model Implementation API , but they are\nnot prefixed with an  _  like the model methods.", 
            "title": "Creating a Store"
        }, 
        {
            "location": "/creating-a-store/#methods", 
            "text": "#find(query, filter)  #findOne(resourceId, filter)  #create(attributes)  #findOneAndUpdate(resourceId, attributes, filter, completeResource)  #findOneAndDelete(resourceId, filter)  #serialize(attributes)  #unserialize(attributes)", 
            "title": "Methods"
        }, 
        {
            "location": "/creating-a-store/#example", 
            "text": "This is a simple example of an in-memory store implementation and usage.", 
            "title": "Example"
        }, 
        {
            "location": "/creating-a-store/#store", 
            "text": "import {NotFoundError} from 'autonym-client-errors';\n\nclass InMemoryStore {\n  constructor () {\n    this._records = [];\n    this._recordsById = {};\n    this._counter = 0;\n  }\n\n  create (attributes) {\n    const id = ++this._counter;\n    const record = {...attributes, id};\n    this._records.push(record);\n    this._recordsById[id] = record;\n    return Promise.resolve(record);\n  }\n\n  find (query) {\n    return Promise.resolve(this._records);\n  }\n\n  findOne (id) {\n    const record = this._recordsById[id];\n    if (record) {\n      return Promise.resolve(record);\n    } else {\n      return Promise.reject(new NotFoundError('No resource found that meets the given criteria.'));\n    }\n  }\n\n  findOneAndUpdate (id, attributes) {\n    const record = this._recordsById[id];\n    if (record) {\n      return Promise.resolve(Object.assign(record, attributes));\n    } else {\n      return Promise.reject(new NotFoundError('No resource found that meets the given criteria.'));\n    }\n  }\n\n  findOneAndDelete (id) {\n    const record = this._recordsById[id];\n    const index = this._records.indexOf(record);\n    if (index   -1) {\n      this._records.splice(index, 1);\n      delete this._recordsById[id];\n      return Promise.resolve(null);\n    } else {\n      return Promise.reject(new NotFoundError('No resource found that meets the given criteria.'));\n    }\n  }\n}\n\nexport default InMemoryStore;", 
            "title": "Store"
        }, 
        {
            "location": "/creating-a-store/#model", 
            "text": "import {Model} from 'autonym';\nimport InMemoryStore from '../stores/in-memory.store';\n\nclass Person extends Model {\n  static _init () {\n    super._implementDefaultStoreCrudMethods(new InMemoryStore());\n  }\n}\n\nexport default Person;", 
            "title": "Model"
        }
    ]
}